@page
@model ChatGPTCaller.Pages.ContentModel
@{
}
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CHAT-DSA</title>
    <link rel="canonical" href="https://cfdcircle.vn" />
    <link rel="stylesheet" href="./css/bootstrap-3.4.1-dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="./css/content.css">
</head>
<body>
    <header class="header">
        <nav class="navbar navbar-inverse">
            <div div class="container-fluid">
                <div class="navbar-header">
                    <a class="navbar-brand" href="./Home">CHAT-DSA</a>
                </div>
                <div class="navbar-header admin" id="admin">
                    <a class="navbar-brand" href="./Admin">Administrator</a>
                </div>
                <ul class="nav navbar-nav">
                    <li class=""><a href="./Home">Home</a></li>
                    <li><a href="./Content">Content</a></li>
                    <li><a href="./Assistant">Assistant</a></li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href=""><span id="usernameSpan"></span></a></li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle glyphicon glyphicon-user" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"> <span class="caret"></span></a>
                        <ul class="dropdown-menu">
                            <li><a href="./Student_infor" onclick="getSinhVien()">Information</a></li>
                            <li><a href="./Student_Update_Data">Updating</a></li>
                            <li><a href="#">Something else here</a></li>
                            <li role="separator" class="divider"></li>
                            <li><a href="#">Help</a></li>
                        </ul>
                    </li>
                    <li onclick="logout()"><a href=""><span class="glyphicon glyphicon-log-out" id="logoutButton" onclick="logout()"></span>Logout</a></li>
                </ul>
            </div>
        </nav>
    </header>
    <!-- Phần trên của body -->
    <div class="container-fluid">
        <div class="tieude">
            <div class="row col-sm-12">
                <div class="heading">
                    <h1>Cấu Trúc Dữ Liệu Và Giải Thuật</h1>
                    <p>Khái niệm cơ bản trong lĩnh vực khoa học máy tính và công nghệ thông tin.</p>
                </div>
            </div>
        </div>
    </div>
    <!-- === MAIN === -->
    <div class="container-fluid">
        <div class="row">
            <!-- Đưa phần Table of Contents lên trước -->
            <div class="col-sm-4">
                
                <div class="sidebar">
                    <h3>MỤC LỤC</h3>
                    <ul class="nav nav-pills nav-stacked" id="toc">
                        <!--Noi Dung Cac Chuong-->

                    </ul>

                </div>

            </div>
            <!-- Phần phải -->
            <div class="col-sm-8 tab-content" id="monhoc">
                <!--Noi Dung Mon Hoc-->
                <div class="container1 tab-content">
                    <div class="tab-pane active" id="CHƯƠNG_1">
                        <h1 class="heading1">
                            CHƯƠNG 1.<br />
                            TỔNG QUAN
                        </h1>
                        <h1 class="heading2">1. 1. VAI TRÒ CỦA THUẬT TOÁN VÀ CẤU TRÚC DỮ LIỆU</h1>
                        <p class="des">
                            Để giải một bài toán trong thực tế bằng chương trình máy tính ta
                            phải bắt đầu từ việc xác định bài toán. Cần nhiều thời gian và công
                            sức để xác định chính xác bài toán cần giải quyết, tức là phải trả lời rõ
                            ràng câu hỏi phải làm gì và như thế nào, vì thông thường hầu hết các
                            bài toán là chưa rõ ràng và có cảm giác phức tạp khi bắt đầu xem xét,
                            tìm hiểu. Để giảm bớt sự phức tạp của các bài toán thực tế, cũng như
                            làm rõ hơn các yêu cầu cần giải quyết, phải hình thức hóa hoặc mô
                            hình hóa bài toán, nghĩa là phát biểu lại bài toán thực tế thành một bài
                            toán hình thức. Khi một bài toán đã được hình thức hoá, ta có thể tìm
                            kiếm cách giải và xác định có hay không một lời giải có sẵn để giải
                            bài toán ấy. Trong trường hợp chưa có lời giải cho bài toán, vẫn có thể
                            dựa vào cách thức ta đã mô hình hóa và các thông tin có liên quan đến
                            bài toán để xây dựng một cách thức giải cho bài toán. Như thế, thông
                            qua thao tác mô hình hóa, sẽ dễ hơn trong việc tìm lời giải cho bài
                            toán ấy – đó chính là giải thuật.
                        </p>
                        <p class="des">
                            Có thể thấy rằng, lời giải là tập hợp các bước hữu hạn nối tiếp
                            nhau để thực hiện các yêu cầu nào đó mà tập hợp của các kết quả
                            thông qua từng bước thực hiện giúp ta giải được bài toán. Có thể thấy
                            rằng các xử lý chi tiết trong từng bước phản ánh các thao tác trên các
                            đối tượng mang thông tin trong bài toán, đó chính là dữ liệu, bao gồm
                            các dữ liệu có sẵn, các dữ liệu nhập vào thêm cho bài toán và các dữ
                            liệu trung gian được tạo ra trong quá trình xử lý. Cách thức dữ liệu lưu
                            trữ và biểu diễn các thông tin cần thiết cho bài toán tạo thành các cấu
                            trúc lưu trữ thông tin – cấu trúc dữ liệu.

                        <p class="des">
                            Như thế khi nói đến lời giải hay nói cách khác là giải thuật thì
                            không thể không nói đến dữ liệu và cách thức xử lý trên dữ liệu ấy.
                            Hơn thế nữa giữa cách thức lưu trữ dữ liệu và giải thuật có mối quan
                            hệ mật thiết với nhau khi giải quyết một bài toán trong tin học.
                        </p>
                        <p class="des">
                            Điều này cũng được Niklaus Wirth - một nhà khoa học uy tín
                            trong lĩnh vực công nghệ thông tin, khẳng định qua một công thức nổi
                            tiếng: Chương trình (Program) = Cấu trúc dữ liệu (Data Structure) +
                            Giải thuật (Algorithm). Điều này nói lên bản chất của việc tìm lời giải
                            cho một bài toán trong tin học là đi tìm một cấu trúc dữ liệu phù hợp
                            để biểu diễn dữ liệu của bài toán và từ đó x y dựng giải thuật phù hợp
                            với cấu trúc dữ liệu đã chọn. Ngày nay, với sự phát triển của các k
                            thuật lập trình, công thức của Wirth không hẳn còn đúng tuyệt đối
                            nữa, nhưng nó vẫn phản ánh sự gắn kết và thể hiện tầm quan trọng của
                            các cấu trúc dữ liệu và giải thuật.
                        </p>

                        <h2 class="heading2">
                            1.2. THUẬT TOÁN
                        </h2>
                        <h3 class="heading3">
                            1.2.1. Định nghĩa thuật toán
                        </h3>
                        <p class="des">
                            Có rất nhiều định nghĩa cũng như cách phát biểu khác nhau về
                            định nghĩa của thuật toán. Theo Thomas H . Cormen trong cuốn sách
                            nổi tiếng viết về thuật toán "Introduction to Algorithm", thuật toán
                            được định nghĩa là một thủ tục tính toán xác định; nhận vào các giá
                            tri  hoặc một tập các giá trị  gọi là giá trị đầu vào và tinh ra các giá
                            tri  hoặc một tập giá trị mới được gọi là giá trị đầu ra. Nói một cách
                            khác, thuật toán giống như là quy trình để hoàn thành một công việc
                            cụ thể xác định nào đó.

                        </p>
                        <h3 class="heading3">
                            1.2.2. Đặc trưng của thuật toán
                        </h3>
                        <p class="des">
                            Thuật toán có các đặc trưng như sau :
                        </p>
                        <p class="des">
                            - <i>Tính đúng đắn:</i> thuật toán cần phải đảm bảo cho một kết quả
                            đúng  sau khi thực hiện đối với các bộ dữ liệu đầu vào. Đây có thể nói
                            là đặc trưng quan trọng nhất đối với một thuật toán.
                        </p>
                        <p class="des">
                            - <i>Tính dừng:</i> thuật toán cần phải đảm bảo  sẽ dừng sau một  số hữu
                            hạn bước.
                        </p>
                        <p class="des">
                            - <i>Tính xác định:</i> các bước của thuật toán phải được phát biểu rõ
                            ràng, cụ thể, tránh gây nhầm lẫn.
                        </p>
                        <p class="des">
                            - <i>Tính hiệu quả:</i>  thuật toán được xem là hiêụ quả nếu có khả năng
                            giải quyết hiệu qủa bài toán đặt ra, đáp ứng yêu cầu về mặt thời gian
                            xử lý hoặc không gian lưu trữ trong bộ nhớ.
                        </p>
                        <p class="des">
                            - <i>Tính phổ quát:</i> thuật toán được gọi là có tính phố quát (phổ
                            biến) nếu có thể giải quyết được một lớp các bài toán tương tự.
                        </p>

                        <h3 class="heading3">
                            1.2.3. Biểu diễn thuật toán
                        </h3>
                        <p class="des">
                            Có nhiều cách khác nhau để biểu diễn thuật toán, gồm: biểu diễn
                            bằng ngôn ngữ tự nhiên, lưu đồ giải và mã giả.
                        </p>

                        <h3 class="heading3">
                            Biểu diễn bằng ngôn ngữ tự nhiên
                        </h3>
                        <p class="des">Ví dụ:</p>
                        <p class="des">
                            Thuật toán tính tổng tất cả các số nguyên dương nhỏ hơn N bằng ngôn ngữ tự nhiên, gồm các bước sau:
                        </p>
                        <pre>
                - Bước 1: Khởi gán giá trị biến S = 0; Khởi gán giá trị biến i = 1;
                - Bước 2: Nếu i< N thì
                S = S + i;
                Ngược lại:
                Chuyển qua bước 4;
                - Bước 3: Gán i = i + 1;
                Quay lại bước 2;
                - Bước 4: Tổng cần tìm là S. 
                    </pre>
                        <p class="des">Nhận xét:</p>
                        <p class="des">
                            Với cách biểu diễn này, có ưu điểm là đơn giản, dễ hiểu. Tuy
                            nhiên, nhược điểm là hơi dài dòng, đôi lúc khó hiểu, không diễn đạt
                            được rõ ràng một cách trực quan nhất từng bước của thuật toán và mối
                            quan hệ giữa chúng.
                        </p>
                        <h3 class="heading3">
                            Biểu diễn bằng lưu đồ giải thuật
                        </h3>
                        <p class="des">
                            Trong cách biểu diễn này sử dụng, hệ thống các ký hiệu để mô tả
                            chức năng, ý nghĩa của từng bước thực hiện trong thuật toán.
                        </p>
                        <p class="des">
                            Hệ thống các ký hiệu và chức n ng của các ký hiệu sử dụng để
                            biểu diễn thuật toán :
                        </p>
                        <img src="./img/monhoc/hinh1.jpg" alt="" srcset="">
                        <p class="des">Ví dụ:</p>
                        <p class="des">
                            Thuật toán tìm phần tử giá trị lớn nhất trong mảng một chiều a
                            gồm n phần tử được biểu diễn bằng lưu đồ như sau:
                        </p>
                        <img src="./img/monhoc/hinh2.jpg" alt="" class="">
                        <p class="des"><i>Nhận Xét:</i></p>
                        <p class="des">
                            Với cách biểu diễn này, có ưu điểm là tăng tính trực quan, rõ
                            ràng trong các bước thực hiện thuật toán, trong đó có đi sâu vào
                            từng chi tiết xử lý cụ thể trong từng bước của thuật toán. Tuy
                            nhiên, hạn chế của cách biểu diễn này là cần nhiều thời gian hơn
                            trong việc xây dựng các bước thực hiện so với biểu diễn bằng ngôn
                            ngữ tự nhiên.
                        </p>
                        <h3 class="heading3">
                            Biểu diễn bằng mã giả
                        </h3>
                        <p class="des">
                            Cách biểu diễn này kết hợp giữa sử dụng ngôn ngữ tự nhiên và
                            một ngôn ngữ lập trình nào đó trong biểu diễn các bước thuật toán.
                        </p>
                        <p class="des"><i>Ví dụ:</i></p>
                        <p class="des">
                            Thuật toán tìm phần tử lớn nhất trong mảng một chiều a gồm n
                            phần tử bằng mã giả được thể hiện như sau:
                        </p>

                        <pre>
                - Bước 1: Khởi gán giá trị biến a_max=a_ 0 ;
                - Bước 2: Khởi gán giá trị biến i=1;
                - Bước 3: while (i< n) 
                { 
                    if (a_max < a_i)
                        a_max = a_i ;
                    i= i +1;
                    }
                end while;
                                </pre>
                        <p class="des">Nhận xét :  </p>
                        <p class="des">
                            Với cách biểu diễn này, có ưu điểm là đỡ cồng kềnh so với cách
                            biểu diễn bằng lưu đồ giải thuật, rõ ràng hơn  so với cách biểu diễn
                            bằng ngôn ngữ tự nhiên. Tuy nhiên, hạn chế của cách biểu diễn này là
                            đòi hỏi phải có kiến thức cơ bản về ngôn ngữ lập trình nào đó để sử
                            dụng biểu diễn các bước thuật toán1.
                        </p>
                        <p class="des">
                            Thông thường hai cách biểu diễn thuật toán sử dụng ph  biến là
                            ngôn ngữ tự nhiên và lưu đồ giải thuật.
                        </p>
                        <h3 class="heading3">
                            1.2.4. Độ phức tạp thuật toán
                        </h3>
                        <p class="des">
                            Định nghĩa về độ phức tạp thuật toán:
                        </p>
                        <p class="des">
                            Cho hai hàm f và g có miền xác định trong tập số tự nhiên. Ta
                            viết f(n) = O(g(n)) và nói f(n) có cấp cao nhất là g(n) khi tồn tại hằng
                            số C và k sao cho |f(n)| ≤  C.g(n) với mọi n > k
                        </p>
                        <p class="des">
                            Thông thường, để đánh giá mức độ tốt, xấu và so sánh các thuật
                            toán cùng loại, có thể dựa trên hai tiêu chuẩn:
                        </p>
                        <p class="des">
                            - Tiêu chuẩn thuật toán đơn giản, dễ hiểu, dễ cài đặt.
                        </p>
                        <p class="des">
                            - Hoặc tiêu chu n dựa vào thời gian thực hiện và tài nguyên tử
                            dụng để thực hiện trên dữ liệu.
                        </p>
                        <p class="des">
                            Trên thực tế các thuật toán hiệu quả thì thường không dễ hiểu,
                            cách cài đặt hiệu quả cũng không dễ dàng thực hiện và hiểu được một
                            cách nhanh chóng và như thế đôi khi thuật toán càng hiệu quả thì càng
                            khó hiểu, cài đặt càng phức tạp. Tuy nhiên, điều này không phải lúc
                            nào cũng đúng trong mọi trường hợp. Do đó, để đánh giá và so sánh
                            các thuật toán, ta thường dựa trên độ phức tạp về thời gian thực hiện
                            của thuật toán, gọi là độ phức tạp thuật toán.
                        </p>
                        <p class="des">
                            Về bản chất độ phức tạp thuật toán là một hàm ước lượng số phép
                            tính mà thuật toán cần thực hiện, trên một bộ dữ liệu đầu vào kích
                            thước N trong bài toán. Khi xem xét  so  sánh các thuật toán cùng loại,
                            ta thường xét độ phức tạp của thuật toán trong các trường hợp  trung
                            bình, xấu nhất và tốt nhất.
                        </p>
                        <p class="des">
                            Phân tích thuật toán là một công việc rất khó khăn, đòi hỏi phải
                            có những hiểu biết sâu sắc về thuật toán và nhiều kiến thức toán học
                            khác. Một công việc mà không phải bất cứ người nào cũng làm được,
                            vì phải hiểu được các khái niệm liên quan.
                        </p>

                        <p class="des">
                            Ðánh giá về thời gian của thuật toán không phải là xác định thời
                            gian tuyệt đối (chạy thuật toán mất bao nhiêu giây, bao nhiêu phút,...)
                            để thực hiện thuật toán mà là xác định mối liên quan giữa dữ liệu đầu
                            vào  (input) của thuật toán và chi phí (số thao tác, số phép tính cộng,
                            trừ, nhân, chia, rút căn,...) để thực hiện thuật toán. Sở dĩ người ta
                            không quan tâm đến thời gian tuyệt đối của thuật toán, vì yếu tố này
                            phụ thuộc vào tốc độ của máy tính, mà các máy tính khác nhau thì có
                            tốc độ rất khác nhau. Như thế, một cách tổng quát, chi phí thực hiện
                            thuật toán là một hàm  số phụ thuộc vào dữ liệu đầu vào:
                        </p>
                        <p class="des --center">
                            T = f(input)
                        </p>
                        <p class="des">
                            Tuy vậy, khi phân tích thuật toán, người ta thường chỉ chú ý đến
                            mối liên quan giữa độ lớn của dữ liệu đầu vào và chi phí. Trong các
                            thuật toán, độ lớn của dữ liệu đầu vào thường được thể hiện bằng
                            một con số nguyên n.  hẳng hạn   sắp xếp N con  số nguyên, tìm con
                            số lớn nhất trong N  số, tính điểm trung bình của N học  sinh, ... Lúc
                            này, người ta thể hiện chi phí thực hiện thuật toán bằng một hàm  số
                            phụ thuộc vào N:
                        </p>
                        <p class="des --center">
                            T = f(N)
                        </p>
                        <p class="des">
                            Việc xây dựng một hàm T tổng quát như trên trong mọi trường
                            hợp của thuật toán là một việc rất khó khăn, nhiều lúc không thể thực
                            hiện được. Chính vì vậy mà ta chỉ xây dựng hàm T cho một số trường
                            hợp đáng chú ý nhất của thuật toán, thường là trường hợp tốt nhất và
                            xấu nhất.
                        </p>
                        <p class="des">
                            Ta xét lại ví dụ thuật toán tìm phần tử giá trị lớn nhất được nêu ở trên:
                        </p>
                        <pre>
        - Bước 1: Ghi nhớ a_max = a1 
        - Bước 2:  hởi gán giá trị biến i = 2 
        - Bước 3: Nếu  (i < N) thì thực hiện : 

        + Bước 3.1: Nếu  ai > a_max ) thì  
                            Ghi nhớ amax = ai 
        + Bước 3.2 : Gán i = i+1 //  tăng i lên một đơn vị 
        Ngược lại :  
                chuyển  sang bước 5. 
        - Bước 4. Trở lại bước 3. 
        - Bước 5. Phần tử lớn nhất dãy a chính là a_max.  kết thúc. 
                                </pre>
                        <p class="des">Nhận xét :</p>
                        <p class="des">
                            - Nếu mảng chỉ có 1 phần tử thì phần tử đó là  số lớn nhất.
                        </p>
                        <p class="des">
                            - Giả  ử mảng có N phần tử và ta đã xác định được phần tử lớn
                            nhất là a_max . Nếu bổ   sung thêm phần tử thứ a_n+1 vào dãy mà a_n+1 > a_max
                            thì a_n+1 chính là phần tử lớn nhất của mảng có N+1 phần tử. Trường
                            hợp ngược lại, nghĩa là a_n+1 < a_max thì a_max vẫn là phần tử lớn nhất của
                            mảng có N+1 phần tử.
                        </p>
                        <p class="des">
                            Trong thuật toán trên, để đơn giản, ta chỉ xem chi phí là số lần so
                            sánh ở bước 3.1 và số lần ghi nhớ trong bước 3.1, như thế :
                        </p>
                        <p class="des">
                            - Trường hợp tốt nhất của thuật toán này xảy ra khi con số lớn
                            nhất nằm đầu dãy (a_max = a1)
                        </p>
                        <p class="des">
                            - Trường hợp xấu nhất xảy ra khi con số lớn nhất nằm ở cuối dãy
                            (a_max = a_N) và dãy được sắp xếp theo thứ tự tăng dần.
                        </p>
                        <p class="des">
                            Dựa theo  sơ đồ khối của thuật toán, ta nhận thấy rằng, trong mọi
                            trường hợp của bài toán, thao tác ở bước 3.1 luôn được thực hiện và số
                            lần thực hiện là N - 1 (ứng với việc xét từ phần tử a_2 đến a_N). Ta gọi
                            đây là chi phí cố định hoặc bất biến của thuật toán.
                        </p>
                        <p class="des">
                            <i>Trường hợp tốt  nhất : </i>
                        </p>
                        <p class="des">
                            Do a_max = a_1 , suy ra với mọi i >2, a_i< a_max. Do đó, điều kiện a_i >
                            a_max ở bước 3.1 luôn không thỏa mãn nên thao tác ghi nhớ không bao
                            giờ được thực hiện. Như vậy, chi phí chung cho trường hợp này chính
                            là chi phí cố định của bài toán.

                        </p>
                        <p class="des --center">
                            T = f(N) = N-1
                        </p>
                        <p class="des">
                            <i>Trường hợ  xấu  nhất:</i>
                        </p>
                        <p class="des">
                            Ta có  với mọi i>1, a_i-1< ai  do định nghĩa mảng được  ắp xếp
                            tăng dần) nên điều kiện a_i>a_max ở bước 3.1 luôn thỏa mãn, thao tác ghi
                            nhớ luôn được thực hiện. Như vậy, ngoài chi phí chung là N-1 phép so
                            ánh, ta cần phải dùng thêm N-1 thao tác ghi nhớ ở bước 3.1. Như
                            vậy, tăng chi phí của trường hợp này:
                        </p>
                        <p class="des --center">
                            T = f(N) = 2(N-1) = 2N-2
                        </p>
                        <p class="des">
                            Tuy chi phí của thuật toán trong trường hợp tốt nhất và xấu nhất
                            có thể nói lên nhiều điều, nhưng vẫn chưa đưa ra được một hình dung
                            tốt nhất về độ phức tạp của thuật toán. Ðể có thể hình dung chính xác
                            về độ phức tạp của thuật toán, ta xét đến một yếu tố khác là độ tăng
                            của chi phí khi độ lớn N của dữ liệu đầu vào tăng.
                        </p>
                        <p class="des">
                            Theo định nghĩa ở trên, ta nhận thấy chi phí thấp nhất và lớn nhất
                            của thuật toán tìm số lớn nhất đều bị chặn bởi O(f(N)) (tồn tại hằng  số
                            C = 10, k = 1 để 2N - 2 < 10N với mọi N>1).
                        </p>
                        <p class="des">
                            Một cách tổng quát, nếu hàm chi phí của thuật toán (xét trong
                            một trường hợp nào đó) bị chặn bởi O(f(N)) thì ta nói rằng thuật toán
                            có độ phức tạp là O(f(N)) trong trường hợp đó.
                        </p>
                        <p class="des">
                            Như vậy, thuật toán tìm  số lớn nhất có độ phức tạp trong trường
                            hợp tốt nhất và xấu nhất đều là O (N). Người ta gọi các thuật toán có
                            độ phức tạp O(N) là các thuật toán có độ phức tạp tuyến tính.
                        </p>
                        <p class="des">
                            Bảng dưới đây thể hiện độ phức tạp của thuật toán được sử dụng
                            rộng rãi. Các độ phức tạp được sắp xếp theo thứ tự tăng dần.
                        </p>
                        <p class="des --center">
                            <table>
                                <head>
                                <tr>
                                    <th>Tên</th>
                                    <th>Ký hiệu</th>
                                </tr>
                                </head>
                                <tbody>
                                    <tr>
                                        <td>Độ phức tạp hằng số</td>
                                        <td>O(C)</td>
                                    </tr>
                                    <tr>
                                        <td>Độ phức tạp logarith</td>
                                        <td>O(logN)</td>
                                    </tr>
                                    <tr>
                                        <td>Độ phức tạp tuyến tính</td>
                                        <td>O(N)</td>
                                    </tr>
                                    <tr>
                                        <td>Độ phức tạp NlogN</td>
                                        <td>O(N*logN)</td>
                                    </tr>
                                    <tr>
                                        <td>Độ phức tạp đa thức</td>
                                        <td>O(Nk)</td>
                                    </tr>
                                    <tr>
                                        <td>Độ phức tạp lũy thừa</td>
                                        <td>O(aN)</td>
                                    </tr>
                                    <tr>
                                        <td>Độ phức tạp giai thừa</td>
                                        <td>O(N!)</td>
                                    </tr>
                                </tbody>
                            </table>
                        </p>
                        <h3 class="heading3">
                            1.2.5. Các chiến lược thiết kế thuật toán
                        </h3>


                    </div>
                    <div class="tab-pane" id="CHƯƠNG_2">
                        <h1 class="heading1">
                            CHƯƠNG 2
                            SẮP XẾP VÀ TÌM KIẾM
                        </h1>
                        <h2 class="heading2" id="2.1">
                            2. 1. MỐI QUAN HỆ GIỮA NHU CẦU SẮP XẾP VÀ TÌM KIẾM
                            DỮ LIỆU
                        </h2>
                        <p class="des">
                            Ngày nay, với sự bùng n của dữ liệu, các công cụ tìm kiếm trên
                            mạng ngày càng trở nên quan trọng hơn bao giờ hết. Chính nhờ các
                            công cụ tìm kiếm này mà người dùng có cơ hội tìm được nhanh chóng
                            các thông tin và dữ liệu cần thiết thông qua thao tác nhập vào các từ
                            khóa nội dung để truy xuất đến các hệ thống lưu trữ và quản lý dữ
                            liệu. Các công cụ tìm kiếm Google, Yahoo,.. là các ví dụ rất cụ thể
                            cho nhu cầu tìm kiếm thông tin, khi m i ngày có hàng tỷ thao tác tìm
                            kiếm được thực hiện trên các công cụ này.
                        </p>
                        <p class="des">
                            Khi xem xét vấn đề ở phạm vi nhỏ hơn, với các ứng dụng cá
                            nhân hàng ngày, như phần mềm soạn thảo Microsoft Word chẳng
                            hạn, thì thao tác tìm kiếm cũng được sử dụng khá nhiều trong quá
                            trình người dùng sử dụng phần mềm. Do đó có thể nói, cho dù ở
                            phạm vi nhỏ trong một ứng dụng soạn thảo hay phạm vi lớn hơn là
                            trong các công cụ tìm kiếm trên mạng thì thao tác tìm kiếm luôn
                            được sử dụng nhiều nhất.
                        </p>
                        <p class="des">
                            Bên cạnh đó, khi nói tới thao tác tìm kiếm thì ta cũng thường
                            đề cập đến thao tác sắp xếp, bởi cả hai thao tác tìm kiếm và sắp xếp
                            đều thực hiện với dữ liệu và khi dữ liệu trở nên bùng n thì việc t
                            chức, sắp xếp lại, hệ thống lại dữ liệu đóng vai trò rất quan trọng,
                            tác động đến hiệu n ng của thao tác tìm kiếm. Để đạt được điều
                            này dữ liệu phải được t chức theo một thứ tự nào đó để hiệu quả
                            hơn, vì vậy nhu cầu sắp xếp dữ liệu cũng rất quan trọng. Như thế,
                            nhu cầu tìm kiếm và nhu cầu sắp xếp dữ liệu luôn song hành với nhau
                            và hai yếu tố này luôn có mối quan hệ tương h lẫn nhau trong các
                            hệ thống quản lý và lưu trữ dữ liệu.
                        </p>
                        <h2 class="heading2" id="2.2">2.2. ĐỊNH NGHĨA BÀI TOÁN SẮP XẾP</h2>
                        <p class="des">
                            Sắp xếp là quá trình xử lý một danh sách các phần tử để đặt
                            chúng theo một thứ tự thỏa mãn một tiêu chu n nào đó dựa trên dữ
                            liệu được lưu trong các phần tử.
                        </p>
                        <p class="des">
                            Bài toán sắp xếp được phát biểu như sau:
                        </p>
                        <p class="des">
                            Cho trước một dãy số a1 , a2 ,… , aN gồm N phần tử được lưu trữ trong cấu trúc dữ liệu mảng. Hãy sắp xếp lại dãy số a1 , a2 ,… , aN, sao cho hình thành được dãy mới ak1 , ak2 ,… ,akN có thứ tự (ví dụ tăng dần, nghĩa là aki > aki-1).
                        </p>
                        <p class="des">
                            Như thế, sau khi sắp xếp xong thứ tự các phần tử trong dãy sẽ
                            thay đ i vị trí sao cho thỏa mãn yêu cầu trên.
                        </p>
                        <h2 class="heading2" id="2.3">2.3. CÁC GIẢI THUẬT SẮP XẾP NỘI</h2>
                        <p class="des">
                            Khi xây dựng các thuật toán sắp xếp, ta cần chú ý tìm cách giảm
                            thiểu những thao tác o ánh và đ i ch các phần tử để t ng hiệu quả
                            của thuật toán. Thao tác sắp xếp có thể tiến hành ở bộ nhớ trong của
                            máy tính trong trường hợp số lượng các phần tử không quá lớn) được
                            gọi là sắp xếp nội hoặc sắp xếp tiến hành trên các thiết bị lưu trữ ngoài
                            (ví dụ như các phần tử dữ liệu lưu trên fil ) được gọi là sắp xếp ngoại.
                        </p>
                        <p class="des">Một số giải thuật sắp xếp nội thông dụng:</p>
                        <ul class="list">
                            <li>Đổi chỗ trực tiếp</li>
                            <li>Chọn trực tiếp (Selection Sort)</li>
                            <li>Chèn trực tiếp</li>
                            <li>Đổi chỗ trực tiếp (Interchane sort)</li>
                            <li>Nổi bọt(Bubble sort)</li>
                            <li>Shaker sort</li>
                            <li>Chèn nhị phân (Binary Insertion sort)</li>
                            <li>Shell sort</li>
                            <li>Heap sort</li>
                            <li>Quick sort</li>
                            <li>Merge sort</li>
                        </ul>
                        <h3 class="heading3" id="2.3.1">2.3.1. Các giải thuật sắp xếp cơ bản</h3>
                        <h4 class="heading4" id="2.3.1.1">2.3.1.1. Giải thuật sắp xếp chọn trực tiếp</h4>
                        <p class="des-bold">Ý tưởng giải thuật</p>
                        <p class="des">
                            Giải thuật chọn trực tiếp chọn phần tử nhỏ nhất trong N phần tử
                            của dãy số đã cho ban đầu. Đưa phần tử này về vị trí đúng là đầu dãy
                            hiện hành. Sau đó, không quan t m đến nó nữa, xem dãy hiện hành
                            chỉ còn N-1 phần tử của dãy ban đầu (bắt đầu từ vị trí thứ 2), lặp lại
                            quá trình trên cho trên dãy N-1 phần tử hiện hành cho đến khi dãy chỉ
                            còn một phần tử.
                        </p>
                        <p class="des-bold">Các bước giải thuật</p>
                        <ul class="list2">
                            <li>Khởi gán giá trị biến i =1</li>
                            <li>
                                Tìm phần tử a[min] nhỏ nhất trong dãy hiện hành từ
                                a[i] đến a[N]
                            </li>
                            <li>Hoán vị phần tử a[min] và a[i]</li>
                            <li>Nếu i ≤ N thì</li>
                        </ul>
                        <ul class="list3">
                            <li>i = i + 1</li>
                            <li>Lặp lại bước 2</li>
                            <li>Ngược lại: Kết thúc</li>
                        </ul>

                        <p class="des-bold">Cài đặt giải thuật</p>
                        <pre>void SelectionSort(int a[], int N) {
        int i, j;
        int min; // chỉ số phần tử nhỏ nhất trong dãy hiện hành
        for (i = 0; i < N - 1; i++) {
        min = i;
        for (j = i + 1; j < N; j++) {
            if (a[j] < a[min])
                min = j; // vị trí phần tử hiện tại nhỏ nhất
        }
        if (min != i) {
            Swap(a[min], a[i]); // hàm hoán vị a[min], a[i]
        }
            }
        }

    void Swap(int& a, int& b) {
        int temp = a;
        a = b;
        b = temp;
    }
                            </pre>
                        <p class="des">Ví dụ:</p>
                        <p class="des">
                            Giả sử cho dãy ban đầu là ={3, 9, 6, 1, 2}. Hãy sp xếp dãy số
                            đã cho có thứ tự t ng dần.
                        </p>
                        <p class="des">Các bước giải thuật được thực hiện như sau:</p>
                        <ul>
                            <li class="square-list">Vòng lặp i=0; dãy : 3, 9, 6, 1, 2, ố phần tử của dãy 5</li>
                            <li class="list">Giả ử phần tử nhỏ nhất Min = [0] = 3</li>
                            <li class="list">Tìm được phần tử nhỏ nhất thực tế Min = [3]=1</li>
                            <li class="list">Hoán vị [0] và [3], được dãy ố mới 1, 9, 6, 3, 2</li>
                            <li class="list">Loại phần tử [0] ra khỏi dãy</li>
                            <li class="square-list">Vòng lặp i=1; dãy :1, 9, 6, 3, 2, ố phần tử của dãy 4</li>
                            <li class="list">Giả ử phần tử nhỏ nhất Min = [1] = 9</li>
                            <li class="list">Tìm được phần tử nhỏ nhất thực tế Min = A[4]=2</li>
                            <li class="list">Hoán vị [1] và [4], được dãy ố mới 1, 2, 6, 3, 9</li>
                            <li class="list">Loại phần tử A[1] ra khỏi dãy</li>
                            <li class="square-list">Vòng lặp i=2; dãy :1, 2, 6, 3, 9, ố phần tử của dãy 3</li>
                            <li class="list">Giả ử phần tử nhỏ nhất Min = [2] = 6</li>
                            <li class="list">Tìm được phần tử nhỏ nhất thực tế Min = [3]=3</li>
                            <li class="list">Hoán vị [2] và [3], được dãy ố mới 1, 2, 3, 6, 9</li>
                            <li class="list">Loại phần tử [2] ra khỏi dãy</li>
                            <li class="square-list">Vòng lặp i=3; dãy :1, 2, 3, 6, 9, ố phần tử của dãy 2</li>
                            <li class="list">Giả ử phần tử nhỏ nhất Min = [3] = 6</li>
                            <li class="list">Tìm được phần tử nhỏ nhất thực tế Min = [3]=6</li>
                            <li class="list">
                                Không hoán vị trong trường hợp này do phần tử giả ử nhỏ
                                nhất và phần tử nhỏ nhất thực tế c ng nằm ở một ví trí trong
                                dãy.
                            </li>
                            <li class="list">Loại phần tử [3] ra khỏi dãy</li>

                            <li class="square-list">Vòng lặp i=4; dãy :1, 2, 3, 6, 9, ố phần tử của dãy 1</li>
                        </ul>
                        <p class="des">Dừng giải thuật</p>
                        <p class="des">Vậy dãy au khi ắp xếp t ng 1, 2, 3, 6, 9</p>
                        <p class="des-bold">Đánh giá giải thuật</p>
                        <p class="des">
                            Với m i giá trị của i, giải thuật thực hiện (N – i – 1) ph p o ánh
                            và vì i chạy từ 0 cho tới (N – 2), giải thuật sẽ cần (N - 1) + (N - 2) +
                            … + 1 = N (N - 1)/2 tức là O(N2) phép so sánh.
                        </p>
                        <p class="des">
                            Trong mọi trường hợp ố lần o ánh của giải thuật là không đ i.
                            M i lần chạy của vòng lặp đối với biến i, có thể có nhiều nhất một lần
                            đ i ch hai phần tử nên ố lần đ i ch nhiều nhất của giải thuật là N.
                            Như vậy, trong trường hợp tốt nhất, giải thuật cần 0 lần đ i ch , trung
                            bình cần N 2 lần đ i ch và xấu nhất cần N lần đ i ch .
                        </p>
                        <h4 class="heading4" id="2.3.1.2">2.3.1.2. Giải thuật sắp xếp đ i ch trực tiếp</h4>
                        <p class="des-bold">Ý tưởng giải thuật</p>
                        <p class="des">
                            Xuất phát từ đầu dãy, tìm tất cả các cặp phần tử gần nhau
                            không thỏa mãn yêu cầu sắp xếp thứ tự (các cặp phần tử nghịch
                            thế , tức thế các cặp phần tử có giá trị theo thứ tự ngược lại so với
                            nhu cầu sắp xếp mong muốn) và tiến hành đ i ch vị trí cho nhau,
                            ví dụ nếu yêu cầu sắp thứ tự t ng và cặp phần tử gần nhau không
                            thỏa mãn là t ng thì tiến hành đ i ch vị trí cho nhau để thỏa điều
                            kiện là sắp thứ tự t ng, lặp lại xử lý trên với các cặp phần tử tiếp
                            theo trong dãy.
                        </p>
                        <p class="des-bold">Các bước giải thuật</p>
                        <ul class="list2">
                            <li>Khởi gán i = 0; // bắ đầ d yệ ừ dãy</li>
                            <li>Khởi gán j = i + 1;</li>
                            <li>Trong khi j < N thì</li>
                            <p class="center">{ Nếu (a[j] < a[i]) //xé cặ hần ử a[i], a[j]</p>
                            <p class="center">Swap (a[i], a[j]); // hàm hoán vị a[i], a[j]</p>
                            <p class="center">j = j+1;}</p>
                            <li>i-i+1;</li>
                        </ul>
                        <ul class="list">
                            <li>Nếu i < N – 1 thì</li>
                            <li>Lặp lại bước 2</li>
                            <li>Ngược lại</li>
                            <li>Dừng giải thuật.</li>
                        </ul>
                        <p class="des-bold">Cài đặt giải thuật</p>
                        <pre>void InterchangeSort(int a[], int N) {
        int i, j;
        for (i = 0; i < N - 1; i++) {
            for (j = i + 1; j < N; j++) {
                if (a[j] < a[i]) {
                    Swap(a[i], a[j]); // hàm hoán vị a[i], a[j]
                }
            }
        }
    }
                            </pre>
                        <p class="des">Ví dụ:</p>
                        <p class="des">
                            Giả ử cho dãy ban đầu là ={3, 9, 6, 1, 2}. Hãy ắp xếp dãy ố
                            đã cho có thứ tự t ng dần.
                        </p>
                        <p class="des">Các bước giải thuật được thực hiện như Sau</p>
                        <ul>
                            <li class="square-list">Vòng lặp i=0; dãy : 3, 9, 6, 1, 2</li>
                            <li class="list">Vòng lặp j = 1 do [0] < [1] không hoán vị</li>
                            <li class="list">Vòng lặp j = 2 do [0] < [2] không hoán vị</li>
                            <li class="list">
                                Vòng lặp j = 3 do [0] > [3] hoán vị [0] và [3]. Dãy
                                mới {1, 9, 6, 3, 2}
                            </li>
                            <li class="list">Vòng lặp j = 4 do [0] < [4] không hoán vị</li>
                            <li class="square-list">Vòng lặp i=1; dãy 1, 9, 6, 3, 2</li>
                            <li class="list">
                                Vòng lặp j = 2 do [1] > A[2] :hoán vị [1] và [2]. Dãy
                                mới {1, 6, 9, 3, 2}
                            </li>
                            <li class="list">
                                Vòng lặp j = 3 do A[1] > A[3] : hoán vị [1] và A[3]. Dãy
                                mới {1, 3, 9, 6, 2}
                            </li>
                            <li class="list">
                                Vòng lặp j = 4 do [1] > [4] hoán vị [1] và [4]. Dãy
                                mới {1, 2, 9, 6, 3}
                            </li>
                            <li class="square-list">Vòng lặp i=2; dãy : 1, 2, 9, 6, 3</li>
                            <li class="list">
                                Vòng lặp j = 3 do [2] > [3] hoán vị [2] và [3]. Dãy
                                mới {1, 2, 6, 9, 3}
                            </li>
                            <li class="list">
                                Vòng lặp j = 4 do [2] > [4] hoán vị [2] và [4]. Dãy
                                mới {1, 2, 3, 9, 6}
                            </li>
                            <li class="square-list">Vòng lặp i=3; dãy : 1, 2, 3, 9, 6</li>
                            <li class="list">
                                Vòng lặp j = 4 do [3] > [4] hoán vị [3] và [4]. Dãy
                                mới {1, 2, 3, 6, 9}
                            </li>
                        </ul>
                        <p class="des">Vậy dãy au khi ắp xếp t ng 1, 2, 3, 6, 9.</p>
                        <p class="des-bold">Đánh giá giải thuật</p>
                        <p class="des">
                            Có thể thấy rằng, so với giải thuật sắp xếp chọn trực tiếp, giải
                            thuật ắp xếp bằng cách đ i ch trực tiếp cần ố bước o ánh tương
                            đương tức là N*(N - 1) 2 lần o ánh. Nhưng ố bước đ i ch hai
                            phần tử cũng bằng với ố lần o ánh : N*(N - 1)/2.
                        </p>
                        <p class="des">
                            Trong trường hợp xấu nhất ố bước đ i ch của giải thuật bằng
                            với ố lần o ánh, trong trường hợp trung bình ố bước đ i ch là N
                            *(N - 1)/4. Trong trường hợp tốt nhất, ố bước đ i ch bằng 0. Như
                            vậy, giải thuật ắp xếp đ i ch trực tiếp nói chung là chậm hơn nhiều
                            o với giải thuật ắp xếp chọn trực triếp, do ố lần đ i ch nhiều hơn.
                        </p>
                        <h4 class="heading4" id="2.3.1.3">2.3.1.3. Giải thuật sắp xếp chèn trực tiếp</h4>
                        <p class="des-bold">Ý tường giải thuật</p>
                        <p class="des">
                            Giả sử cho dãy số a1, a2 ,… , aN , trong đó có i phần tử đầu tiên đã
                            có thứ tự. tưởng giải thuật là tìm cách chèn ph n tử ai+1 vào vị trí
                            thích hợp của đoạn từ phần tử a1 đến ai sao cho từ a1 đến ai+1 cũng có
                            thứ tự.
                        </p>
                        <p class="des-bold">Các bước giải thuật</p>
                        <ul class="list2">
                            <li>Khởi gán i = 1; //giả sử có đoạn a[1] đã được sắp</li>
                            <li>
                                Gán x = a[i]; // tìm vị trí pos thích hợ rong đoạn
                                a[1] đế a[i-1] để chèn a[i] vào
                            </li>
                            <li>
                                Dời ch các phần tử từ a[po ] đến a[i-1] sang phải 1 vị
                                trí để dành ch cho a[i]
                            </li>
                            <li>Gán a[pos] = x; //đoạn a[1]..a[i] đã được sắp</li>
                            <li>Gán i = i+1</li>
                        </ul>
                        <ul class="list">
                            <li>Nếu i < N thì</li>
                            <li>Lặp lại bước 2</li>
                            <li>Ngược lại</li>
                            <li>Dừng giải thuật.</li>
                        </ul>
                        <p class="des-bold">Cài đặt giải thuật</p>
                        <pre>void InsertionSort(int a[], int N) {
        int i, pos, x;
        for (i = 1; i < N; i++) {
            x = a[i];
            pos = i - 1;
            while ((pos >= 0) && (a[pos] > x)) {
                a[pos + 1] = a[pos];
                pos--;
            }
            a[pos + 1] = x;
        }
    }
                            </pre>
                        <p class="des">Ví dụ:</p>
                        <p class="des">
                            Giả sử cho dãy ban đầu là ={3, 9, 6, 1, 2}. Hãy ắp xếp dãy ố
                            đã cho có thứ tự t ng dần.
                        </p>
                        <p class="des">Các bước giải thuật được thực hiện như sau:</p>
                        <ul>
                            <li class="square-list">Vòng lặp i=1; dãy : 3, 9, 6, 1, 2</li>
                            <li class="list">Phần tử đã ắp xếp [0] = 3</li>
                            <li class="list">
                                So ánh phần tử [1]= 9 và [0]= 3 để chèn [1] vào dãy
                                để được dãy có 2 phần tử [0], [1] t ng dần
                            </li>
                            <li class="list">Không thực hiện đ i ch [0], [1], do [1] > [0]</li>
                            <li class="list">Ta được 2 phần tử ắp t ng trong dãy 3, 9, 6, 1, 2</li>

                            <li class="square-list">Vòng lặp i=2; dãy : 3, 9, 6, 1, 2</li>
                            <li class="list">Phần tử đã ắp xếp [0], [1]</li>
                            <li class="list">
                                So ánh phần tử [2]= 6 và { [0]= 3, [1]=9} để chèn
                                [2] vào dãy để được dãy có 3 phần tử { [0], [1], [2]}
                                t ng
                            </li>
                            <li class="list">Do [2]< [1], nên dời ch qua lại [1] và [2]</li>
                            <li class="list">Ta được 3 phần tử ắp t ng trong dãy 3, 6, 9, 1, 2</li>

                            <li class="square-list">Vòng lặp i=3; dãy 3, 6, 9, 1,</li>
                            <li class="list">Phần tử đã ắp xếp [0], [1],</li>
                            <li class="list">
                                So ánh phần tử [3]= 1 và {A[0]=3, A[1]=6, A[2]=9} để
                                chèn A[3] vào dãy để được dãy có 4 phần tử { [0], [1],
                                A[2], A[3]} t ng dần
                            </li>
                            <li class="list">
                                Do [3] nhỏ hơn đồng thời [0], [1], [2], nên dời ch
                                A[0], A[1], [2] qua một vị trí, [3] thế ch [0] au dời
                                ch .
                            </li>
                            <li class="list">Ta được 4 phần tử ắp t ng trong dãy 1, 3, 6, 9, 2</li>

                            <li class="square-list">Vòng lặp i=4; dãy : 1, 3, 6, 9, 2</li>
                            <li class="list">Phần tử đã ắp xếp [0], A[1], A[2], A[3]</li>
                            <li class="list">
                                So ánh phần tử [4]= 2 và {A[0]=1, A[1]=3, A[2]=6,
                                A[3]=9} để chèn [4] vào dãy để được dãy có 5 phần tử
                                {A[0], A[1], A[2], A[3], A[4] } t ng dần
                            </li>
                            <li class="list">
                                Do A[4] nhỏ hơn đồng thời [1], [2], A[3] nên dời ch
                                A[1], A[2], [3] qua một vị trí, [4] thế ch [1] au dời
                                ch .
                            </li>
                            <li class="list">Ta được 5 phần tử ắp t ng trong dãy 1, 3, 6, 2, 9</li>

                        </ul>
                        <p class="des">Vậy dãy au khi ắp xếp t ng 1, 2, 3, 6, 9</p>
                        <p class="des-bold">Đánh giấ giải thuật</p>
                        <p class="des">
                            Với m i bước i, ta cần thực hiện so sánh phần tử hiện tại (a[i])
                            với nhiều nhất là i phần tử và vì i chạy từ 1 tới N - 1 nên ta phải thực
                            hiện nhiều nhất 1 + 2 + … + N - 1 = N(N - 1)/2 tức là O(N2) ph p o
                            ánh tương tự như giải thuật sắp xếp chọn trực tiếp. Tuy nhiên, vòng
                            lặp while không phải lúc nào cũng được thực hiện và nếu thực hiện thì
                            cũng không nhất định là lặp i lần nên trên thực tế giải thuật ắp xếp
                            chèn nhanh hơn o với giải thuật ắp xếp chọn.
                        </p>
                        <p class="des">
                            Trong trường hợp tốt nhất, giải thuật chỉ cần ử dụng đúng N lần
                            o ánh và 0 lần đ i ch . Trên thực tế một dãy bất kỳ gồm nhiều dãy
                            con đã được sắp nên giải thuật chèn hoạt động khá hiệu quả.
                        </p>
                        <p class="des">
                            Giải thuật ắp xếp chèn trực tiếp là giải thuật nhanh nhất trong
                            các giải thuật ắp xếp cơ bản.
                        </p>
                        <h4 class="heading4" id="2.3.1.4">2.3.1.4. Giải thuật sắp xếp n i bọt</h4>
                        <p class="des-bold">Ý tưởng giải thuật</p>
                        <p class="des">
                            Xuất phát từ cuối dãy, đ i ch các cặp phần tử kế cận nhau để
                            đưa phần tử nhỏ hơn hoặc lớn hơn trong cặp phần tử đó về vị trí đúng
                            ở đầu dãy hiện hành, au đó ẽ không x t đến nó ở bước tiếp theo, do
                            vậy ở lần xử lý thứ i sẽ có vị trí đầu dãy là i. Lặp lại xử lý trên cho đến
                            khi không còn cặp phần tử nào để xét.
                        </p>
                        <p class="des-bold">Các bước giải thuật</p>
                        <ul class="list2">
                            <li>Khởi gán i= 0;</li>
                            <li style="text-align: center; margin: 0 auto;">
                                Khởi gán j = N - 1; //Duyệt từ cuối dãy ngược về vị trí i
                                Trong khi (j > i) thực hiện :
                                { Nếu (a[j] < a[j-1]) thì
                                Swap(a[j],a[j-1]); // hoán vị a[j], a[j-1]
                                j = j - 1;
                                }
                            </li>
                            <li>i=i+1;</li>
                        </ul>
                        <ul class="list">
                            <li>Nếu i < N thì</li>
                            <li>Lặp lại bước 2</li>
                            <li>Ngược lại</li>
                            <li>Dừng giải thuật.</li>
                        </ul>
                        <p class="des-bold">Cài đặt giải thuật</p>
                        <pre>void BubbleSort(int a[], int N) {
        int i, j;
        for (i = 0; i < N - 1; i++) {
            for (j = N - 1; j > i; j--) {
                if (a[j] < a[j - 1]) {
                    Swap(a[j], a[j - 1]); // hàm hoán vị a[j], a[j-1]
                }
            }
        }
    }
                            </pre>
                        <p class="des">Ví dụ:</p>
                        <p class="des">
                            Giả ử cho dãy ban đầu là A= {5, 6, 2, 2, 10, 12, 9, 10, 9, 3}. Hãy
                            ắp xếp dãy ố đã cho có thứ tự t ng dần
                        </p>
                        <p class="des">Các bước của giải thuật được thực hiện như sau:</p>
                        <img src="./img/table.jpg" alt="table" style="width: 100%; height: auto;"></img>
                        <p class="des-bold">Đánh giá giải thuật</p>
                        <p class="des">
                            Giải thuật có đô phức tạp là O(N*(N - 1)/2) = O(N2), bằng ố lần
                            o ánh và ố lần đ i ch nhiều nhất của giải thuật (trong trường hợp
                            xấu nhất). Giải thuật ắp xếp n i bọt là giải thuật chậm nhất trong số
                            các giải thuật sắp xếp cơ bản, nó còn chậm hơn giải thuật ắp xếp đ i
                            ch trực tiếp mặc d có ố lần o ánh bằng nhau, nhưng do đ i ch
                            hai phần tử kề nhau nên ố lần đ i ch nhiều hơn
                        </p>

                        <h3 class="heading3" id="2.3.2">2.3.2. Giải thuật sắp xếp cây – Heap sort</h3>
                        <p class="des-bold">Ý tưởng giải thuật</p>
                        <p class="des">
                            Ý tưởng cơ bản của giải thuật là thực hiện sắp xếp thông qua
                            việc tạo các H ap, trong đó heap là một cây nhị phân hoàn chỉnh có
                            tính chất là giá trị khóa ở nút cha bao giờ cũng lớn hơn giá trị khóa
                            ở các nút con. Nói một cách khác, giả sử nếu ta có dãy phần tử a1,
                            a2,… , aN thì khi đó dãy ẽ trở thành heap khi mọi phần tử ai phải thỏa
                            mãn ai a2i và ai  a2i+1 gọi là các phần tử liên đới.
                        </p>
                        <p class="des">Việc thực hiện giải thuật này được chia làm 2 giai đoạn:</p>
                        <ul class="list">
                            <li>
                                Giai đoạn thứ nhất : Tạo heap từ dãy ban đầu. Th o định nghĩa
                                của heap thì nút cha bao giờ cũng lớn hơn tất cả các nút con. Do đó,
                                nút gốc của heap bao giờ cũng là phần tử lớn nhất.
                            </li>
                            <li>
                                Giai đoạn thứ hai : Sắp xếp dãy dựa trên heap tạo được ở giai
                                đoạn trước đó. Do nút gốc là nút lớn nhất nên nó sẽ được chuyển về
                                vị trí cuối cùng của dãy và phần tử cuối cùng sẽ được thay vào gốc
                                của h ap. hi đó, ta có một cây mới, c y này chưa phải heap (với
                                số nút bớt đi 1), ta tiếp tục chuyển cây thành heap và lặp lại quá
                                trình này cho tới khi heap chỉ còn một nút. Đó chính là phần tử bé
                                nhất của dãy và được đặt lên đầu dãy.
                            </li>
                        </ul>
                        <p class="des-bold">Các bước giải thuật</p>
                        <ul class="list">
                            <li>Giai đoạn 1: Hiệu chỉnh dãy số ban đầu thành Heap</li>
                            <li>Giai đoạn 2: Sắp xếp dãy số dựa trên Heap</li>
                        </ul>
                        <ul class="list2">
                            <li>
                                Đưa phần tử lớn nhất về vị trí đúng ở cuối dãy:
                                r = n;
                                Hoán vị (a1, ar);
                            </li>
                            <li>
                                Loại bỏ phần tử lớn nhất ra khỏi Heap:
                                r = r – 1;
                                Hiệu chỉnh phần còn lại của dãy a1, a2... ar thành
                                Heap.
                            </li>
                            <li>Nếu r > 1 thì // Heap còn phần tử</li>
                        </ul>
                        <ul class="list3">
                            <li>Lặp lại Bước 2.</li>
                            <li>Ngược lại: Kết thúc.</li>
                        </ul>
                        <p class="des-bold">Cài đặt giải thuật</p>
                        <p class="des">Giai đoạn 1 : Hiệu chỉnh dãy số ban đầu thành Heap</p>
                        <p class="des-italic">Hiệu chỉnh a1, a1+1, ..,ar thành Heap</p>
                        <pre>void shift(int a[], int l, int r) {
        int x,i,j;
        i=1;
        j=2*i+1;
        x=a[i];
        while (j<=r) {
            if (j<r) if (a[j]<a[j+1]) j++;
            if (x>=a[j]) return;
            else {
                a[i]=a[j];
                a[j]=x;
                i=j;
                j=2*i+1;
                x=a[i];
            }
        }
    }
                            </pre>
                        <p class="des">Giai đoạn 2 : Sắp xếp dãy số dựa trên Heap</p>
                        <p class="des-italic">Hiệu chỉnh a0,..an-1 thành Heap</p>
                        <pre>void HeapSort(int a[], int N) {
        int l;
        l=N/2-1;
        while (l>=0)
            { shift(a,l,N-1);
            l=l-1;
        }
    }
                            </pre>
                        <p class="des">Giai đoạn 2: Sắp xếp dãy số</p>
                        <p class="des-italic">Hàm HeapSort</p>
                        <pre>void HeapSort(int a[], int N) {
        int r;
        CreateHeap(a, N);
        r=N-1;
        while (r>0) {
            Swap(a[0],a[r]);// hóan vị a[0] (nút gốc ), a[r]
            r--;
            if(r>0)
                CreateHeap(a,r);
        }
    }                        
                            </pre>
                        <p class="des">Ví dụ:</p>
                        <p class="des">Giả sử cho dãy số A= { 6, 5, 3, 1, 8, 7, 2, 4 }. Hãy sắp xếp dãy số đã cho tăng dần</p>
                        <p class="des">Các bước của giải thuật được thực hiện như sau:</p>
                        <p class="des"><strong>Giai đoạn 1:</strong> Hiệu chỉnh dãy ban đầu thành Heap</p>
                        <table class="table2">
                            <tr>
                                <th class="th-bold">Heap</th>
                                <th class="th-bold">Thêm vào Heap</th>
                                <th class="th-bold">Hoán vị</th>
                            </tr>
                            <tr>
                                <td>Null</td>
                                <td>6</td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>6</td>
                                <td>5</td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>6, 5</td>
                                <td>3</td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>6, 5, 3</td>
                                <td>1</td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>6, 5, 3, 1</td>
                                <td>8</td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>6, <strong>5</strong>, 3, 1, <strong>8</strong></td>
                                <td></td>
                                <td>5, 8</td>
                            </tr>
                            <tr>
                                <td><strong>6</strong>,<strong>8</strong>, 3, 1, 5</td>
                                <td></td>
                                <td>6, 8</td>
                            </tr>
                            <tr>
                                <td>6, 8, 3, 1, 5</td>
                                <td>7</td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>8, 6, <strong>3</strong>, 1, 5</td>
                                <td></td>
                                <td>3, 7</td>
                            </tr>
                            <tr>
                                <td>8, 6, 7, 1, 5, 3</td>
                                <td>2</td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>8, 6, 7, 1, 5, 3, 2</td>
                                <td>4</td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>8, 6, 7, <strong>1</strong>, 5, 3, 2, <strong>4</strong></td>
                                <td></td>
                                <td>1, 4</td>
                            </tr>
                            <tr>
                                <td>8, 6, 7, 4, 5, 3, 2, 1</td>
                                <td></td>
                                <td></td>
                            </tr>
                        </table>
                        <p class="des"><strong>Giai đoạn 2:</strong> Sắp xếp dãy số dựa trên Heap</p>
                        <table class="table3">
                            <tr>
                                <th class="th-bold">Heap</th>
                                <th class="th-bold">Hoán vị</th>
                                <th class="th-bold">Loại phần tử</th>
                                <th class="th-bold">Dãy đã sắp xếp</th>
                                <th class="th-bold">Ghi chú</th>
                            </tr>
                            <tr>
                                <td><strong>8</strong>, 6, 7, 4, 5, 3, 2, <strong>1</strong></td>
                                <td>8, 1</td>
                                <td></td>
                                <td></td>
                                <td>Hoán vị phần tử 8 và 1</td>
                            </tr>
                            <tr>
                                <td>1, 6, 7, 4, 5, 3, 2, <strong>8</strong></td>
                                <td></td>
                                <td>8</td>
                                <td>8</td>
                                <td>Loại phần tử 8 khỏi heap và thêm vào dãy đã sắp</td>
                            </tr>
                            <tr>
                                <td><strong>1</strong>, 6, 7, 4, 5, 3, 2</td>
                                <td>1, 7</td>
                                <td></td>
                                <td>8</td>
                                <td>Hoán vị phần tử 7 và 1, do hai phần tử này không thỏa mãn yêu cầu của heap</td>
                            </tr>
                            <tr>
                                <td>7, 6, <strong>1</strong>, 4, 5, <strong>3</strong>, 2</td>
                                <td>1, 3</td>
                                <td></td>
                                <td>8</td>
                                <td>Hoán vị phần tử 3 và 1, do hai phần tử này không thỏa mãn yêu cầu của heap</td>
                            </tr>
                            <tr>
                                <td>7, 6, 3, 4, 5, 1, <strong>2</strong></td>
                                <td>7, 2</td>
                                <td></td>
                                <td>8</td>
                                <td>Hoán vị phần tử 7 và 2</td>
                            </tr>
                            <tr>
                                <td>2, 6, 3, 4, 5, 1, 7</td>
                                <td></td>
                                <td>7</td>
                                <td>7, 8</td>
                                <td>Loại phần tử 7 khỏi heap và thêm vào dãy đã sắp</td>
                            </tr>
                            <tr>
                                <td><strong>2, 6</strong>, 3, 4, 5, 1</td>
                                <td>2, 6</td>
                                <td></td>
                                <td>7, 8</td>
                                <td>Hoán vị phần tử 2 và 6, do hai phần tử này không thỏa mãn yêu cầu của heap</td>
                            </tr>
                            <tr>
                                <td>6, <strong>2</strong>, 3, 4, <strong>5</strong>, 1</td>
                                <td>2, 5</td>
                                <td></td>
                                <td>7, 8</td>
                                <td>Hoán vị phần tử 2 và 5, do hai phần không thỏa mãn yêu cầu của heap </td>
                            </tr>
                            <tr>
                                <td><strong>6</strong>, 5, 3, 4, 2, <strong>1</strong></td>
                                <td>6, 1</td>
                                <td></td>
                                <td>7, 8</td>
                                <td>Hoán vị phần tử 6 và 1</td>
                            </tr>
                            <tr>
                                <td>1, 5, 3, 4, 2, <strong>6</strong></td>
                                <td></td>
                                <td>6</td>
                                <td>6, 7, 8</td>
                                <td>Loại phần tử 6 khỏi heap và thêm vào dãy đã sắp</td>
                            </tr>
                            <tr>
                                <td><strong>1, 5</strong>, 3, 4, 2</td>
                                <td>1, 5</td>
                                <td></td>
                                <td>6, 7, 8</td>
                                <td>Hoán vị phần tử 1 và 5, do hai phần tử này không thỏa mãn yêu cầu đã sắp</td>
                            </tr>
                            <tr>
                                <td>5, <strong>1</strong>, 3, <strong>4</strong>, 2</td>
                                <td>1, 4</td>
                                <td></td>
                                <td>6, 7, 8</td>
                                <td>Hóa vị phần tử 1 và 4, do hai phần tử này không thỏa mãn yêu cầu đã sắp</td>
                            </tr>
                            <tr>
                                <td><strong>5</strong>, 4, 3, 1, <strong>2</strong></td>
                                <td>5, 2</td>
                                <td></td>
                                <td>6, 7, 8</td>
                                <td>Hóan vị phần tử 5 và 2</td>
                            </tr>
                            <tr>
                                <td>2, 4, 3, 1, <strong>5</strong></td>
                                <td></td>
                                <td>5</td>
                                <td>5, 6, 7, 8</td>
                                <td>Loại phần tử 5 khỏi heap và thêm vào dãy đã sắp</td>
                            </tr>
                            <tr>
                                <td><strong>2, 4</strong>, 3, 1</td>
                                <td>2, 4</td>
                                <td></td>
                                <td>5, 6, 7, 8</td>
                                <td>Hoán vị phần tử 2 và 4, do hai phần tử này không thỏa mãn yêu cầu của heap</td>
                            </tr>
                            <tr>
                                <td><strong>4</strong>, 2, 3, <strong>1</strong></td>
                                <td>4, 1</td>
                                <td></td>
                                <td>5, 6, 7, 8</td>
                                <td>Hóa vị phần tử 4 và 1</td>
                            </tr>
                            <tr>
                                <td>1, 2, 3, <strong>4</strong></td>
                                <td></td>
                                <td>4</td>
                                <td>4, 5, 6, 7, 8</td>
                                <td>Loại phần tử 4 khỏi heap và thêm vào dãy đã sắp</td>
                            </tr>
                            <tr>
                                <td><strong>1</strong>, 2, <strong>3</strong></td>
                                <td>1, 3</td>
                                <td></td>
                                <td>4, ,5 ,6, 7, 8</td>
                                <td>Hoán vị phần tử 1 và 3 do hai phần tử này không thỏa mãn yêu cầu của heap</td>
                            </tr>
                            <tr>
                                <td><strong>3</strong>, 2, <strong>1</strong></td>
                                <td>3, 1</td>
                                <td></td>
                                <td>4, 5, 6, 7, 8</td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>1, 2, <strong>3</strong></td>
                                <td></td>
                                <td>3</td>
                                <td>3, 4, 5, 6, 7, 8</td>
                                <td>Loại phần tử 3 khỏi heap và thêm vào dãy đã sắp</td>
                            </tr>
                            <tr>
                                <td><strong>1, 2</strong></td>
                                <td>1, 2</td>
                                <td></td>
                                <td>3, 4, 5, 6, 7, 8</td>
                                <td>Hoán vị phần tử 1 và 2 do hai phần tử này không thỏa mãn yêu cầu của heap</td>
                            </tr>
                            <tr>
                                <td><strong>2, 1</strong></td>
                                <td>2, 1</td>
                                <td></td>
                                <td>3, 4, 5, 6, 7, 8</td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>1, <strong>2</strong></td>
                                <td></td>
                                <td>2</td>
                                <td>2, 3, 4, 5, 6, 7, 8</td>
                                <td>Loại phần tử 2 khỏi heap và thêm vào dãy đã sắp</td>
                            </tr>
                            <tr>
                                <td><strong>1</strong></td>
                                <td></td>
                                <td>1</td>
                                <td>2, 3, 4, 5, 6, 7, 8</td>
                                <td>Loại phần tử 1 khỏi heap và thêm vào dãy đã sắp</td>
                            </tr>
                            <tr>
                                <td></td>
                                <td></td>
                                <td></td>
                                <td>1, 2, 3, 4, 5, 6, 7, 8</td>
                                <td>Dãy đã được sắp tăng</td>
                            </tr>
                        </table>
                        <p class="des">Vậy dãy sau khi được sắp tăng: 1, 2, 3, 4, 5, 6, 7, 8</p>
                        <p class="des-bold">Đánh giá giải thuật</p>
                        <h3 class="heading3" id="2.3.3">2.3.3. Giải thuật sắp xếp độ phức tạp giảm dần – Shell sort</h3>
                        <p class="des-bold">Ý tưởng giải thuật</p>
                        <p class="des">Giải thuật này nhằm mục tiêu cải tiến phương pháp chèn trực tiếp bằng cách phân hoạch dãy thành các dãy con, sắp xếp các dãy con th o phương pháp chèn trực tiếp và tiến hành d ng phương pháp chèn trực tiếp sắp xếp lại cả dãy.</p>
                        <p class="des">Ph n chia dãy ban đầu thành những dãy con gồm các phần tử ở cách nhau h vị trí.</p>
                        <p class="des">Dãy ban đầu: a<sub>1</sub>, a<sub>2</sub>,... a<sub>n</sub> được x m như ự xen kẽ của các dãy con sau :</p>
                        <ul class="list">
                            <li>Dãy con thứ nhất: a<sub>1</sub> a<sub>h+1</sub> a<sub>h+2</sub>...</li>
                            <li>Dãy con thứ hai: a<sub>2</sub> a<sub>h+2</sub> a<sub>2h+2</sub>...</li>
                            <li>Dãy con thứ ba: a<sub>h</sub> a<sub>2h</sub> a<sub>3h</sub></li>
                        </ul>
                        <p class="des">Tiến hành sắp xếp các phần tử trong cùng dãy con sẽ làm cho các phần tử được đưa về vị trí đúng tương đối</p>
                        <p class="des">Giảm khoảng cách h để tạo thành các dãy con mới. Dừng giải thuật khi h=1</p>
                        <p class="des-bold">Các bước giải thuật</p>
                        <ul class="list">
                            <li><em>Bước 1:</em></li>
                        </ul>
                        <ul>
                            <li>Chọn k khoảng cách h[1], h[2], ..., h[k]</li>
                            <li>Khởi gán i=1</li>
                        </ul>
                        <ul class="list"><li><em>Bước 2:</em></li></ul>
                        <ul>
                            <li>Ph n chia dãy ban đầu thành các dãy con cách nhau h[i] khoảng cách</li>
                            <li>Sắp xếp các dãy con theo phương pháp chèn trực tiếp</li>
                        </ul>
                        <ul class="list"><li><em>Bước 3:</em></li></ul>
                        <ul>
                            <li>Gán i = i+1</li>
                            <li>Nếu (i>k) thì ngừng giải thuật</li>
                            <li>Ngược lại: lặp lại bước 2</li>
                        </ul>
                        <p class="des-bold">Cài đặt giải thuật</p>
                        <pre>void ShellSort(int a[], int N, int h[]. int k) {
        int step, i, j, x, len;
        for (step = 0; step < k; step++) {
            len = h[step];
            for (i = len; i < N; i++) {
                x = a[i];
                j = i - len; // <em> a[j] đứng kề trước a[i] trong cùng dãy con</em>
                // <em> sắp xếp dãy con chứa x bằng phương pháp chèn trực tiếp</em>
                while ((x<a[j]) && (j>=0)) {
                    a[j+len] = a[j];
                    j = j - len;
                }
                a[j+len] = x;
            }
        }
    }
                            </pre>
                        <p class="des">Ví dụ:</p>
                        <p class="des">Giả ử cho dãy A= {6, 5, 3, 2, 8, 7, 1, 4}. Hãy ắp xếp dãy ố đã cho t ng dần.</p>
                        <p class="des">Các bước của giải thuật được thực hiện như sau, với h= 3, 2, 1:</p>
                        <p class="des-center">h = 3</p>
                        <table>
                            <tr>
                                <th>6</th>
                                <th class="th-bold">5</th>
                                <th>3</th>
                                <th>2</th>
                                <th class="th-bold">8</th>
                                <th>7</th>
                                <th>1</th>
                                <th class="th-bold">4</th>
                            </tr>
                        </table>
                        <br>
                        <table>
                            <tr>
                                <th>6</th>
                                <th class="th-bold">4</th>
                                <th>3</th>
                                <th>2</th>
                                <th class="th-bold">5</th>
                                <th>7</th>
                                <th>1</th>
                                <th class="th-bold">8</th>
                            </tr>
                        </table>
                        <br>
                        <table>
                            <tr>
                                <th class="th-bold">6</th>
                                <th>4</th>
                                <th>3</th>
                                <th class="th-bold">2</th>
                                <th>5</th>
                                <th>7</th>
                                <th class="th-bold">1</th>
                                <th>8</th>
                            </tr>
                        </table>
                        <p class="des-center">...</p>
                        <p class="des-center">h = 2</p>
                        <table>
                            <tr>
                                <th>1</th>
                                <th class="th-bold">4</th>
                                <th>3</th>
                                <th class="th-bold">6</th>
                                <th>5</th>
                                <th>7</th>
                                <th>2</th>
                                <th class="th-bold">8</th>
                            </tr>
                        </table>
                        <br>
                        <table>
                            <tr>
                                <th class="th-bold">1</th>
                                <th>4</th>
                                <th class="th-bold">2</th>
                                <th>6</th>
                                <th class="th-bold">3</th>
                                <th>7</th>
                                <th class="th-bold">5</th>
                                <th>8</th>
                            </tr>
                        </table>
                        <p class="des-center">h = 1</p>
                        <table>
                            <tr>
                                <th class="th-bold">1</th>
                                <th class="th-bold">4</th>
                                <th class="th-bold">2</th>
                                <th class="th-bold">6</th>
                                <th class="th-bold">3</th>
                                <th class="th-bold">7</th>
                                <th class="th-bold">5</th>
                                <th class="th-bold">8</th>
                            </tr>
                        </table>
                        <p class="des-center">Kết quả sắp xếp</p>
                        <table>
                            <tr>
                                <th>1</th>
                                <th>2</th>
                                <th>3</th>
                                <th>4</th>
                                <th>5</th>
                                <th>6</th>
                                <th>7</th>
                                <th>8</th>
                            </tr>
                        </table>
                        <p class="des-bold">Đánh giá giải thuật</p>
                        <p class="des">
                            Giải thuật ở trên là phiên bản nguyên thủy của giải thuật do
                            D.L.Sh ll đưa ra n m 1959. Dễ thấy rằng, để giải thuật hoạt động
                            đúng thì chỉ cần dãy bước h giảm dần về 1 sau m i bước lặp là được,
                            đã có một số nghiên cứu về việc chọn dãy bước h cho giải thuật nhằm
                            t ng hiệu quả của giải thuật.
                        </p>
                        <p class="des">
                            Giải thuật tương đối dễ cài đặt, tuy nhiên việc đánh giá độ phức
                            tạp tính toán chính xác của Shell sort là tương đối khó, vì phụ thuộc
                            vào giá trị bước h, cụ thể như sau :
                        </p>
                        <ul class="list">
                            <li>Nếu các bước h được chọn theo thứ tự ngược dựa trên công thức: 4i+1 + 3*2i+1, …, 77, 23, 8,1 thì độ phức tạp tính toán là O(N4/3)</li>
                            <li>Nếu các bước h được chọn theo thứ tự ngược dựa trên công thức: 2i - 1, …, 15, 7, 3, 1 thì độ phức tạp tính toán là O(N3/2)</li>
                            <li>Nếu bước h được chọn theo thứ tự ngược dựa trên công thức: 2i3j,…, 16, 12, 9, 8, 6, 4, 3, 2, 1 thì độ phức tạp tính toán là O(N(logN)2)</li>
                        </ul>
                        <h3 class="heading3" id="2.3.4">2.3.4. Giải thuật sắp xếp dựa trên phân hoạch – Quick sort</h3>
                        <p class="des-bold">Ý tưởng giải thuật</p>
                        <p class="des">
                            Dựa trên việc chia dãy ban đầu thành 3 dãy con là S1, S2, S3,
                            trong đó dãy S1 bao gồm các phần tử a(k) < x, S2 là các phần tử a(k)
                            = x và S3 bao gồm các phần tử a(k) > x như hình dưới đ y. Trong đó,
                            dãy con S2 đã có thứ tự. Nếu dãy con S1 và S3 chỉ có một phần tử thì
                            chúng cũng đã có thứ tự. hi đó dãy con ban đầu đã được sắp. Ngược
                            lại, nếu dãy con S1 và S3 có nhiều hơn một phần tử ta lần lượt phân
                            hoạch từng dãy con th o tư tưởng dãy ban đầu
                        </p>
                        <table class="table-bold">
                            <tr>
                                <th class="th-bold">a<sub>k</sub> &le; x</th>
                                <th class="th-bold">a<sub>k</sub> = x</th>
                                <th class="th-bold">a<sub>k</sub> &ge; x</th>
                            </tr>
                        </table>
                        <p class="des-bold">Các bước giải thuật</p>
                        <ul>
                            <li class="list"><em>Bước 1:</em> Nếu (left &ge; right) thì //dãy có ít nhất hơn 2 phần tử </li>
                            <ul class="list text-center">Kết thúc giải thuật //dãy đã được sắp xếp</ul>
                            <li class="list"><em>Bước 2:</em> Phân hoạch dãy a<sub>left</sub>, a<sub>right</sub> thành các đoạn: a<sub>left</sub>.. a<sub>j</sub>..a<sub>j+1</sub>..a<sub>i-1</sub>,a<sub>i</sub>.. a<sub>right</sub></li>
                            <li class="list-bullet">Đoạn 1: a<sub>left</sub>..a<sub>j</sub> &le; x</li>
                            <li class="list-bullet">Đoạn 2: a<sub>j+1</sub>.. a<sub>i-1</sub> = x</li>
                            <li class="list-bullet">Đoạn 3: a<sub>i</sub>.. a<sub>right</sub> &ge; x</li>
                            <li class="list"><em>Bước 3:</em> Sắp xếp đoạn 1: a<sub>left</sub>.. a<sub>j</sub></li>
                            <li class="list"><em>Bước 4:</em> Sắp xếp đoạn 3: a<sub>i</sub>.. a<sub>right</sub></li>
                        </ul>
                        <p class="des-bold">Chi tiết giải thuật</p>
                        <ul class="list">
                            <li><em>Bước 1:</em> Chọn tùy ý một phần tử a[k] trong dãy là giá trị mốc ( left ≤ k ≤ right):</li>
                        </ul>
                        <ul>
                            <li>i = left;</li>
                            <li>j = right;</li>
                            <li>x = a[k];</li>
                        </ul>
                        <ul class="list"><li><em>Bước 2:</em> Phát hiện và hiệu chỉnh cặp phần tử a[i], a[j] nằm sai chỗ:</li></ul>
                        <li class="list-bullet"><em>Bước 2a:</em> Trong khi (a[i] < x)</li>
                        <ul><li>i++;</li></ul>
                        <li class="list-bullet"><em>Bước 2b:</em> Trong khi (a[i] > x)</li>
                        <ul><li>j--;</li></ul>
                        <li class="list-bullet"><em>Bước 2c:</em> Nếu i < j</li>
                        <ul><li>swap(a[i],a[j]); <em>//hoán vị a[i] và a[j]</em></li></ul>
                        <li class="list"><em>Bước 3:</em> Nếu i < j</li>
                        <ul>
                            <li>Quay lại bước 2</li>
                            <li>Ngược lại: Dừng giải thuật</li>
                        </ul>
                        <p class="des-bold">Cài đặt giải thuật</p>
                        <pre>void QuickSort(int a[], int left, int right) {
        int i, j, x;    
        x = a[(left+right)/2];                    
        i = left;
        j = right;
        while (i < j) {
            while (a[i] < x) i++;
            while (a[j] > x) j--;
            if (i <= j) {
                swap(a[i], a[j]); // hoán vị a[i] và a[j]
                i++;
                j--;
            }
        }
        if (left < j) QuickSort(a, left, j);
        if (i < right) QuickSort(a, i, right);
    }
                            </pre>
                        <p class="des">Ví dụ:</p>
                        <p class="des">Giả sử cho dãy A= {6, 5, 3, 2, 8, 7, 1, 4}. Hãy sắp xếp dãy số đã cho t ng dần.</p>
                        <p class="des">Các bước của giải thuật được thực hiện như sau :</p>
                        <li class="square-list">Phân hoạch đoạn left =1, right = 8</li>
                        <ul><li>x = A[(left +right)/2]= A[4] = 2</li></ul>
                        <table>
                            <tr>
                                <td>6</td>
                                <td>5</td>
                                <td>3</td>
                                <td>2</td>
                                <td>8</td>
                                <td>7</td>
                                <td>1</td>
                                <td>4</td>
                            </tr>
                        </table>
                        <br>
                        <table>
                            <tr>
                                <td>1</td>
                                <td><strong>2</strong></td>
                                <td>5</td>
                                <td>3</td>
                                <td>8</td>
                                <td>7</td>
                                <td>6</td>
                                <td>4</td>
                            </tr>
                        </table>
                        <p class="des">Đoạn 1 gồm 1 phần tử nên đã được sắp, đoạn 2 cũng đã được sắp, tiếp tục thực hiện phân hoạch đoạn 3 : {5, 3, 8, 7, 6, 4}</p>
                        <li class="square-list">Cập nhật lại left= 3, right=8 : x = A[5]=8</li>
                        <table>
                            <tr>
                                <td class="colored"><strong>1</strong></td>
                                <td class="colored"><strong>2</strong></td>
                                <td>5</td>
                                <td>3</td>
                                <td>8</td>
                                <td>7</td>
                                <td>6</td>
                                <td>4</td>
                            </tr>
                        </table>
                        <br>
                        <table>
                            <tr>
                                <td class="colored"><strong>1</strong></td>
                                <td class="colored"><strong>2</strong></td>
                                <td>5</td>
                                <td>3</td>
                                <td><strong>8</strong></td>
                                <td>7</td>
                                <td>6</td>
                                <td>4</td>
                            </tr>
                        </table>
                        <br>
                        <table>
                            <tr>
                                <td class="colored"><strong>1</strong></td>
                                <td class="colored"><strong>2</strong></td>
                                <td>5</td>
                                <td>3</td>
                                <td>4</td>
                                <td>7</td>
                                <td>6</td>
                                <td><strong>8</strong></td>
                            </tr>
                        </table>
                        <p class="des">Sau phân hoạch, đoạn 3 không có phần tử nào lớn hơn 8, nên số phần tử đoạn này không có. Đoạn 1 gồm các phần tử : {5, 3, 7, 6, 4}, đoạn 2 gồm {8} và đã được sắp.Tiếp tục phân hoạch đoạn 1.</p>
                        <li class="square-list">Cập nhật lại left= 3, right=7 : x = A[5]=7</li>
                        <table>
                            <tr>
                                <td class="colored"><strong>1</strong></td>
                                <td class="colored"><strong>2</strong></td>
                                <td>5</td>
                                <td>3</td>
                                <td>7</td>
                                <td>6</td>
                                <td>4</td>
                                <td class="colored"><strong>8</strong></td>
                            </tr>
                        </table>
                        <br>
                        <table>
                            <tr>
                                <td class="colored"><strong>1</strong></td>
                                <td class="colored"><strong>2</strong></td>
                                <td>5</td>
                                <td>3</td>
                                <td>7</td>
                                <td>6</td>
                                <td>4</td>
                                <td class="colored"><strong>8</strong></td>
                            </tr>
                        </table>
                        <br>
                        <table>
                            <tr>
                                <td class="colored"><strong>1</strong></td>
                                <td class="colored"><strong>2</strong></td>
                                <td>5</td>
                                <td>3</td>
                                <td>6</td>
                                <td>4</td>
                                <td>7</td>
                                <td class="colored"><strong>8</strong></td>
                            </tr>
                        </table>
                        <p class="des">Sau phân hoạch, đoạn 3 không có phần tử nào lớn hơn 7, nên số phần tử đoạn này không có. Đoạn 1 gồm các phần tử : {5, 3, 6, 4}, đoạn 2 gồm {7} và đã được sắp. Tiếp tục phân hoạch đoạn 1.</p>
                        <li class="square-list"> Cập nhật lại left= 3, right=6 : x = A[4]=3</li>
                        <table>
                            <tr>
                                <td class="colored"><strong>1</strong></td>
                                <td class="colored"><strong>2</strong></td>
                                <td>5</td>
                                <td><strong>3</strong></td>
                                <td>6</td>
                                <td>4</td>
                                <td class="colored"><strong>7</strong></td>
                                <td class="colored"><strong>8</strong></td>
                            </tr>
                        </table>
                        <br>
                        <table>
                            <tr>
                                <td class="colored"><strong>1</strong></td>
                                <td class="colored"><strong>2</strong></td>
                                <td><strong>3</strong></td>
                                <td>5</td>
                                <td>6</td>
                                <td>4</td>
                                <td class="colored"><strong>7</strong></td>
                                <td class="colored"><strong>8</strong></td>
                            </tr>
                        </table>
                        <p class="des">Sau phân hoạch, đoạn 1 không có phần tử nào nhỏ hơn 3, nên số phần tử đoạn này không có. Đoạn 3 gồm các phần tử : {5, 6, 4}, đoạn 2 gồm {3} và đã được sắp. Tiếp tục phân hoạch đoạn 3.</p>
                        <li class="square-list">Cập nhật lại left= 4, right=6 : x = A[5]=6</li>
                        <table>
                            <tr>
                                <td class="colored"><strong>1</strong></td>
                                <td class="colored"><strong>2</strong></td>
                                <td class="colored"><strong>3</strong></td>
                                <td>5</td>
                                <td>6</td>
                                <td>4</td>
                                <td class="colored"><strong>7</strong></td>
                                <td class="colored"><strong>8</strong></td>
                            </tr>
                        </table>
                        <br>
                        <table>
                            <tr>
                                <td class="colored"><strong>1</strong></td>
                                <td class="colored"><strong>2</strong></td>
                                <td class="colored"><strong>3</strong></td>
                                <td>5</td>
                                <td><strong>6</strong></td>
                                <td>4</td>
                                <td class="colored"><strong>7</strong></td>
                                <td class="colored"><strong>8</strong></td>
                            </tr>
                        </table>
                        <br>
                        <table>
                            <tr>
                                <td class="colored"><strong>1</strong></td>
                                <td class="colored"><strong>2</strong></td>
                                <td class="colored"><strong>3</strong></td>
                                <td>5</td>
                                <td>4</td>
                                <td><strong>6</strong></td>
                                <td class="colored"><strong>7</strong></td>
                                <td class="colored"><strong>8</strong></td>
                            </tr>
                        </table>
                        <p class="des">Sau phân hoạch, đoạn 3 không có phần tử nào lớn hơn 6, nên số phần tử đoạn này không có. Đoạn 1 gồm các phần tử : {5, 4}, đoạn 2 gồm {6} và đã được sắp. Tiếp tục phân hoạch đoạn 1</p>
                        <li class="square-list">Cập nhật lại left= 4, right=5 : x = A[4]=5</li>
                        <table>
                            <tr>
                                <td class="colored"><strong>1</strong></td>
                                <td class="colored"><strong>2</strong></td>
                                <td class="colored"><strong>3</strong></td>
                                <td>5</td>
                                <td>4</td>
                                <td class="colored"><strong>6</strong></td>
                                <td class="colored"><strong>7</strong></td>
                                <td class="colored"><strong>8</strong></td>
                            </tr>
                        </table>
                        <br>
                        <table>
                            <tr>
                                <td class="colored"><strong>1</strong></td>
                                <td class="colored"><strong>2</strong></td>
                                <td class="colored"><strong>3</strong></td>
                                <td><strong>5</strong></td>
                                <td>4</td>
                                <td class="colored"><strong>6</strong></td>
                                <td class="colored"><strong>7</strong></td>
                                <td class="colored"><strong>8</strong></td>
                            </tr>
                        </table>
                        <br>
                        <table>
                            <tr>
                                <td class="colored"><strong>1</strong></td>
                                <td class="colored"><strong>2</strong></td>
                                <td class="colored"><strong>3</strong></td>
                                <td>4</td>
                                <td><strong>5</strong></td>
                                <td class="colored"><strong>6</strong></td>
                                <td class="colored"><strong>7</strong></td>
                                <td class="colored"><strong>8</strong></td>
                            </tr>
                        </table>
                        <p class="des">Sau phân hoạch, đoạn 3 không có phần tử nào lớn hơn 5, nên số phần tử đoạn này không có. Đoạn 1 gồm 1 phần tử {4} và đã được sắp, đoạn 2 gồm {5} và đã được sắp</p>
                        <table>
                            <tr>
                                <td class="colored"><strong>1</strong></td>
                                <td class="colored"><strong>2</strong></td>
                                <td class="colored"><strong>3</strong></td>
                                <td class="colored"><strong>4</strong></td>
                                <td class="colored"><strong>5</strong></td>
                                <td class="colored"><strong>6</strong></td>
                                <td class="colored"><strong>7</strong></td>
                                <td class="colored"><strong>8</strong></td>
                            </tr>
                        </table>
                        <li class="square-list">Cập nhật lại left= 4, right=4 : Dừng giải thuật</li>
                        <p class="des">Dãy đã được sắp xếp tăng dần: 1, 2, 3, 4, 5, 6, 7, 8</p>
                        <p class="des-bold">Đánh giá giải thuật</p>
                        <p class="des">Hiệu quả của giải thuật phụ thuộc vào việc chọn giá trị mốc. Nếu mỗi lần phân hoạch đều chọn phần tử trung gian của dãy, khi đó dãy phân chia làm hai phần bằng nhau thì cần log2(N) phân hoạch. Nếu chia dãy trên mà chọn mốc là cực đại hoặc cực tiểu thì dãy đã cho chia làm hai phần, phần đầu có một phần tử, phần còn lại có (N - 1) phần tử do vậy cần N lần phân hoạch.</p>
                        <h3 class="heading3" id="2.3.5">2.3.5. Giải thuật sắp xếp trộn trực tiếp – Merge sort</h3>
                        <p class="des-bold">Ý tưởng giải thuật</p>
                        <p class="des">
                            Giả sử cho dãy ban đầu a1, a2, …, an. Ta luôn có thể coi dãy
                            đã cho là tập hợp liên tiếp của các dãy có thứ tự và gọi các dãy có
                            thứ tự này là các dãy con.
                        </p>
                        <p class="des">
                            Trong giải thuật này, vấn đề là tìm cách phân hoạch dãy ban đầu
                            thành các dãy con. Sau khi phân hoạch, dãy ban đầu sẽ được tách
                            thành hai dãy phụ theo nguyên tắc phân phối luân phiên dãy con. Sau
                            đó, trộn từng cặp dãy con của hai dãy phụ thành một dãy con của dãy
                            ban đầu. Ta nhận thấy số dãy con của dãy ban đầu lúc này giảm đi ít
                            nhất là một nửa. Cứ thế sau một số bước, ta sẽ nhận được dãy ban đầu
                            với số dãy con bằng 1, có nghĩa là đã ắp xếp xong.
                        </p>
                        <p class="des">
                            Trộn trực tiếp: đ y là phương pháp trộn đơn giản nhất. Việc
                            phân hoạch dãy ban đầu đơn giản như au với dãy ban đầu có n phân
                            tử, ta cứ phân hoạch thành n dãy con. Vì m i dãy con chỉ có 1 phần tử47
                            nên nó là dãy có thứ tự. Cứ m i lần tách – trộn, chiều dài của dãy con
                            sẽ được nh n đôi.
                        </p>
                        <p class="des-bold">Các bước giải thuật</p>
                        <li class="list"><em>Bước 1: </em>Khởi động k = 1 //Với k là chiều dài dãy con</li>
                        <li class="list"><em>Bước 2: </em>Phân phối dãy a = a1, a2, …, an vào hai dãy phụ b, c theo nguyên tắc phân phối luân phiên từng dãy con.</li>
                        <ul>
                            <li>b = a1, …, ak, a2k+1, …, a3k,...</li>
                            <li>c = ak+1, …, a2k, a3k+1, …, an</li>
                        </ul>
                        <li class="list"><em>Bước 3: </em>Từ 2 dãy phụ b, c, ta trộn từng cặp dãy con và đưa vào dãy a.</li>
                        <li class="list"><em>Bước 4: </em>k = k*2</li>
                        <ul>
                            <li>Nếu (k<n) thì quay lai bước 2 </li>
                            <li>Ngược lại: Kết thúc giải thuật</li>
                        </ul>
                        <p class="des-bold">Cài đặt giải thuật</p>
                        <pre>void MergeSort(int a[], int left, int right) {
        if (left < right) {
            int q = (left + right) / 2;
            MergeSort(a, left, q);
            MergeSort(a, q+1, right);
            Merge(a, left, q, right);
        }
    }
                            </pre>
                        <p class="des">Ví dụ:</p>
                        <p class="des">Giả ử cho dãy A = {12, 13, 45, 32, 100, 34, 65, 10}. Hãy ắp xếp dãy ố đã cho t ng dần.</p>
                        <p class="des">Các bước của giải thuật được thực hiện như au :</p>
                        <p class="des">
                            Có 8 phần tử cần được sắp xếp: ý tưởng của giải thuật là thay vì
                            sắp xếp 8 phần tử, ta chia dãy đó ra làm đôi và sắp xếp các dãy con rồi
                            ghép 2 dãy con lại. Ta thực hiện như au
                        </p>
                        <li class="list">Chia đôi dãy ban đầu thành hai dãy con là {12, 13, 45, 32} gọi là dãy A và {100, 34, 65, 10}gọi là dãy B</li>
                        <li class="list">Sắp 2 dãy con lại: {12, 13, 45, 32} gọi là dãy A, {100, 34, 65, 10} gọi là dãy B.</li>
                        <ul>
                            <li class="list4">
                                Muốn sắp ta cũng làm như trên: chia đôi , được 2 dãy
                                mới là dãy A11 = {12,13}; dãy A12 = {45,32}. hia đôi B
                                được 2 dãy mới là dãy B11 = {100,34}; dãy B12 = {65,10}
                            </li>
                            <li class="list4">Sắp xếp A11, B11 , A12 , B12</li>
                            <li class="list4">
                                Muốn sắp xếp 11 thì ta cũng chia đôi được 2 dãy con là
                                A21 = {12} A22 = {13}.
                            </li>
                            <li class="list4">
                                Sắp 2 dãy con trên được (đơn giản vì chỉ có một phần tử )
                                A21 = {12}; A22 = {13}. Sắp xong ta trộn lại thành dãy A11
                                = {12,13}.
                            </li>
                            <li class="list4">
                                Tương tự sắp xếp cho B11, A12, B12 ta cũng có dãy B11 =
                                {34, 100}; dãy B12 = {10, 65}; dãy A12 = {32, 45}.
                            </li>
                            <li class="list4">
                                Sắp xếp xong, ta sẽ trộn A11, A12 lại thành dãy A = {12 13
                                32 45}
                            </li>
                            <li class="list4">
                                Trộn B11, B12 thành dãy B = {10, 34, 65,100}. Sắp xong
                                A, B, ta sẽ trộn lại thành dãy ban đầu: {10,12,13, 32, 34, 45,
                                65,100}.
                            </li>
                        </ul>
                        <p class="des">Vậy dãy được sắp xếp t ng dần: {10,12,13, 32, 34, 45, 65,100}.</p>
                        <p class="des-bold">Đánh giá giải thuật</p>
                        <p class="des">
                            Nhận thấy rằng, số lần lặp của bước 2 (phân phối) và bước 3
                            (trộn) bằng log<sub>2</sub>>N. Chi phí thực hiện bước 2 và bước 3 tỉ lệ thuận với
                            N. Như vậy, ta có thể ước tính chi phí thực hiện của giải thuật này
                            thuộc O(Nlog<sub>2</sub>N).
                        </p>
                        <h2 class="heading2" id="2.4">2.4 ĐỊNH NGHĨA BÀI TOÁN TÌM KIẾM</h2>
                        <p class="des">Cho dãy có N phần tử a<sub>0</sub>, a<sub>1</sub>,..., a<sub>n-1</sub> có giá trị và phần tử có giá trị X cần tìm. Hãy xác định xem phần tử X có xuất hiện trong dãy N phần tử hay không.</p>
                        <p class="des">
                            Với bài toán này, ta quan t m tới bài toán tìm kiếm trên một dãy
                            các phần tử hoặc một danh ách các phần tử c ng kiểu và tập các phần
                            tử này được gọi là không gian tìm kiếm của bài toán. Không gian tìm
                            kiếm được lưu hoàn toàn trong bộ nhớ trong của máy tính. Kết quả
                            tìm kiếm là vị trí của phần tử thỏa mãn điều kiện tìm kiếm.
                        </p>
                        <p class="des">Có hai giải thuật tìm kiếm thông dụng :</p>
                        <ul class="list">
                            <li>Giải thuật tìm kiếm tuần tự</li>
                            <li>Giải thuật tìm kiếm nhị phân</li>
                        </ul>
                        <h2 class="heading2" id="2.5">2.5. CÁC GIẢI THUẬT TÌM KIẾM NỘI</h2>
                        <h3 class="heading3" id="2.5.1">2.5.1. Giải thuật tìm kiếm tuyến tính</h3>
                        <p class="des-bold">Ý tưởng giải thuật</p>
                        <p class="des">
                            Duyệt qua tất cả các phần tử của dãy, trong quá trình duyệt nếu
                            tìm thấy phần tử có giá trị khóa bằng với giá trị khóa cần tìm kiếm thì
                            trả về vi trí của phần tử tìm được. Ngược lại, nếu duyệt tới hết dãy mà
                            vẫn không có phần tử thỏa mãn yêu cầu trả về giá trị mặc định nào đó.
                        </p>
                        <p class="des-bold">Các bước giải thuật</p>
                        <li class="list"><em>Bước 1:</em> Khởi gán i=0</li>
                        <li class="list"><em>Bước 2:</em> So sánh a[i] với giá trị x cần tìm, có 2 khả năng:</li>
                        <ul>
                            <li class="list4">Nếu (a[i] = x ) thì tìm thấy x và dừng giải thuật</li>
                            <li class="list4">Ngược lại: Chuyển sang bước 3</li>
                        </ul>
                        <li class="list"><em>Bước 3:</em> i=i+1 //Xét tiếp phần tử kế tiếp trong dãy</li>
                        <ul>
                            <li class="list4">Nếu (i < n) thì quay lại bước 2</li>
                            <li class="list4">Ngược lại: Kết thúc giải thuật</li>
                        </ul>
                        <p class="des-bold">Cài đặt giải thuật</p>
                        <pre>int sequential_search(int a[], int N, int x) {
        for (int i = 0; i < N; i++) {
            if (a[i] == x) return i;
            else 
                return -1;
        }
    }
                            </pre>
                        <p class="des-bold">Đánh giá giải thuật</p>
                        <p class="des">Độ phức tạp thuật toán trong trường hợp trung bình và xấu nhất là O(N).Trong trường hợp tốt nhất thuật toán có độ phức tạp O(1). </p>
                        <p class="des">Nhận xét:</p>
                        <p class="des">
                            Số phép so sánh của thuật toán trong trường hợp xấu nhất là 2*N.
                            Để giảm thiểu số phép so sánh trong vòng lặp cho thuật toán, ta có
                            thêm phần tử “lính canh” vào cuối dãy, khi đó giải thuật sẽ có được
                            hiệu quả cao hơn.
                        </p>
                        <pre>int LinearSearch(int a[],int N, int x)
    {
        int i=0;
        a[N]=x; // a[N] là phần tử “lính canh”
        while (a[i]!=x)
            i++;
            if (i==N)
                return 0; // Tìm không thấy x
            else
                return 1; // Tìm thấy
    }
                            </pre>
                        <h3 class="heading3" id="2.5.2">2.5.2. Giải thuật tìm kiếm nhị phân</h3>
                        <p class="des-bold">ý tưởng giải thuật</p>
                        <p class="des">
                            Giải thuật tìm kiếm nhị phân là giải thuật d ng để tìm kiếm phần
                            tử trong một dãy đã được sắp xếp. Trong m i bước, ta tiến hành so
                            sánh phần tử cần tìm với phần tử nằm ở chính giữa dãy. Nếu hai phần
                            tử bằng nhau thì thao tác tìm kiếm thành công và giải thuật kết thúc.
                            Nếu chúng không bằng nhau thì tùy vào phần tử nào lớn hơn, giải
                            thuật lặp lại bước so sánh trên với nửa đầu hoặc nửa sau của dãy và cứ
                            tiếp tục như thế.
                        </p>
                        <p class="des-bold">Các bước giải thuật</p>
                        <p class="des">Giả sử dãy tìm kiếm hiện hành bao gồm các phần tử nằm trong a<sub>left</sub>, a<sub>right</sub> , các bước của giải thuật như sau: </p>
                        <li class="list"><em>Bước 1:</em> Khởi gán left=0; Khởi gán right=N-1; </li>
                        <li class="list"><em>Bước 2:</em></li>
                        <li class="square-list">mid= (left+right) / 2; //chỉ số phần tử giữa dãy hiện hành </li>
                        <li class="square-list">So sánh a[mid] với x. Có 3 khả năng  </li>
                        <ul>
                            <li>a[mid] = x: Tìm thấy x và trả về vị trí mid</li>
                            <li>a[mid] > x: Cập nhật Right= mid-1;</li>
                            <li>a[mid] < x: Cập nhật Left= mid+1;</li>
                        </ul>
                        <li class="list"><em>Bước 3:</em> Nếu (Left <=Right) thì // còn phần tử trong dãy </li>
                        <ul>
                            <li>Quay lại bước 2</li>
                            <li>Ngược lại: Dừng giải thuật</li>
                        </ul>
                        <p class="des-bold">Cài đặt giải thuật</p>
                        <pre>int BinarySearch(int a[],int n,int x) {
        int left, right, mid;
        left=0;
        right=n-1;
        do
            {mid=(left+right) / 2;
            if (a[mid]==x)
                return 1;
            else if (a[mid]< x)
                left=mid+1;
                else
                    right=mid-1;
        }while(left<=right);
        return 0;
    }</pre>

                        <p class="des">Ví dụ:</p>
                        <p class="des">Giả sử cho dãy A = {12, 8, 2, 14, 3,5}. Phần tử cần tìm là X = 3. Các bước của giải thuật ẽ được thực hiện như sau: </p>
                        <li class="list">left = 0, right =5, mid = (left + right) /2 = 3</li>
                        <table>
                            <tr>
                                <td>12</td>
                                <td>8</td>
                                <td><strong>2</strong></td>
                                <td>14</td>
                                <td>3</td>
                                <td>5</td>
                            </tr>
                        </table>
                        <p class="des">So sánh : A[mid] = 2 và X = 3 : không phải X</p>
                        <li class="list">Cập nhật lại left = 4</li>
                        <li class="list">left = 4, right =5, mid = (left + right) /2 = 4</li>
                        <table>
                            <tr>
                                <td>12</td>
                                <td>8</td>
                                <td>2</td>
                                <td>14</td>
                                <td><strong>3</strong></td>
                                <td>5</td>
                            </tr>
                        </table>
                        <p class="des">So sánh : A[mid] = 3 và X = 3 : phần tử được tìm thấy</p>
                        <li class="list">Dừng giải thuật</li>
                        <p class="des">Phần tử X = 3 được tìm thấy</p>
                        <p class="des-bold">Đánh giá giải thuật</p>
                        <p class="des">
                            Với giải thuật này, trong quá trình tìm kiếm, số lượng phần tử
                            trong dãy cần xem xét giảm đi một nửa sau m i bước, nên thời gian
                            thực thi của thuật toán là O(log<sub>2</sub>N).
                        </p>
                        <p class="des-bold">BÀI TẬP CHƯƠNG 2</p>
                        <ul>
                            <li class="number-list">Trình bày ngắn gọn tư tưởng các giải thuật tìm kiếm, các giải thuật này có thể được vận dụng trong các trường hợp nào, cho ví dụ minh họa? </li>
                            <li class="number-list">Hãy trình bày các ưu, nhược điểm của các giải thuật tìm kiếm?</li>
                            <li class="number-list">Hãy cài đặt các giải thuật tìm kiếm bằng cách sử dụng các kiểu vòng lặp khác nhau (while , do…while , for) và có nhận xét về các trường hợp này.</li>
                            <li class="number-list">Giả sử cho một dãy số nguyên N phần tử, các phần tử có thứ tự tăng dần và được yêu cầu áp dụng giải thuật tìm kiếm tuyến tính để tìm kiếm phần tử trong dãy, hãy thực hiện các yêu cầu sau : </li>
                            <ul>
                                <li class="letter-list">Cài đặt theo yêu cầu trên và đánh giá về số lần so sánh trong các trường hợp tìm kiếm phần tử khi cho phần tử cần tìm kiếm nằm ở đầu dãy, cuối dãy và giữa dãy.</li>
                                <li class="letter-list">Cải tiến giải thuật tìm tuyến tính để phù hợp với giả thiết đã cho</li>
                                <li class="letter-list">Đánh giá và o ánh tính hiệu quả về bộ nhớ và số giao tác khi thực hiện hai giải thuật trong câu a và câu b.</li>
                            </ul>
                            <li class="number-list">Giả sử cho một dãy số nguyên N phần tử, các phần tử có thứ tự  giảm dần và được yêu cầu áp dụng giải thuật tìm kiếm nhị phân để tìm kiếm phần tử trong dãy, hãy thực hiện các yêu cầu sau : </li>
                            <ul>
                                <li class="letter-list">Cài đặt theo yêu cầu trên bằng cách dùng k thuật đệ qui và không dùng k thuật đệ qui. </li>
                                <li class="letter-list">Đánh giá về số lần o ánh trong các trường hợp tìm kiếm phần tử khi cho phần tử cần tìm kiếm nằm ở đầu dãy, cuối dãy và giữa dãy trong câu a.</li>
                            </ul>
                            <li class="number-list">Giả sử cho một dãy số nguyên gồm M phần tử (100 < M < 30.000),sau đó chọn ngẫu nhiên trong dãy M một số nguyên K, áp dụng đồng thời 2 giải thuật tìm kiếm nhị phân và tuyến tính để tìm K trong M. Hãy cho nhận xét về thời gian thực hiện nếu phát sinh ngẫu nhiên 100 lần M và K khác nhau và thực hiện hai giải thuật nêu trên để tìm K trong M.</li>

                            <li class="number-list">Giả sử cho một dãy số nguyên N phần tử (100 < N < 10.000).</li>
                            <ul>
                                <li class="letter-list">Hãy cho biết thời gian thực hiện giải thuật tìm kiếm tuyến tính để tìm kiếm một phần tử K trong dãy N khi áp dụng k thuật phần tử lính canh và khi không dùng k thuật phần tử “lính canh”. </li>
                                <li class="letter-list">Thời gian thực hiện giải thuật khi áp dụng k thuật lính canh và khi không dùng k thuật lính canh trong câu a có tỷ lệ tuyến tính với nhau khi t ng hoặc giảm số phần tử N không? Vì sao? </li>
                            </ul>
                            <li class="number-list">Giả sử cho một mảng 2 chiều các số nguyên có kích thước M x N (100 < M < 10.000), (100 < N < 20.000). Hãy cho biết thời gian thực hiện giải thuật tìm kiếm tuyến tính để tìm kiếm một phần tử K trong mảng 2 chiều trên, khi áp dụng k thuật phần tử “lính canh” và khi không dùng k thuật phần tử “lính canh”. </li>
                            <li class="number-list">Giả sử sử dụng hàm Random trong ++ để phát sinh ngẫu nhiên dãy 10.000 số nguyên và lưu trong fil X. </li>
                            <ul>
                                <li class="letter-list">Hãy áp dụng giải thuật tìm tuyến tính để tìm kiếm số nguyên trong file X (K được phát sinh ngẫu nhiên) </li>
                                <li class="letter-list">Cho nhận xét về thời gian tìm kiếm trong câu a sẽ như thế nào, nếu thực hiện 5 lần chạy với dãy số nguyên có 100, 1.000, 5.000, 10.000, 50.000 phần tử trong m i lần chạy</li>
                            </ul>
                            <li class="number-list">Giả sử sử dụng hàm Random trong ++ để phát sinh ngẫu nhiên dãy 10.000 số nguyên và lưu trong fil X. </li>
                            <ul>
                                <li class="letter-list">Hãy áp dụng giải thuật tìm nhị ph n để tìm kiếm số nguyên trong file X (K được phát sinh ngẫu nhiên). </li>
                                <li class="letter-list">Nhận xét về thời gian tìm kiếm trong câu a sẽ như thế nào, nếu thực hiện 5 lần chạy với dãy số nguyên có 100, 1.000, 5.000, 10.000, 50.000 phần tử trong m i lần chạy.</li>
                            </ul>
                            <li class="number-list">Hãy viết chương trình minh họa trực quan hóa các giải thuật tìm kiếm.</li>
                            <li class="number-list">Hãy trình bày ngắn gọn tư tưởng của các giải thuật sắp xếp?</li>
                            <li class="number-list">Hãy trình bày ưu điểm và hạn chế của các giải thuật sắp xếp, đề xuất cách tốt nhất để khắc phục hạn chế của các giải thuật này.</li>
                            <li class="number-list">Giả sử sử dụng hàm Random trong ++ để phát sinh ngẫu nhiên dãy số nguyên có kích thước 100, 1.000, 5.000, 10.000, 50.000 số. Hãy cài đặt các giải thuật sắp xếp để sắp dãy số nguyên đã cho theo thứ tự t ng dần và nhận xét về thời gian thực hiện của các giải thuật. </li>
                            <li class="number-list">Viết chương trình o ánh các giải thuật Selection sort, Heap Sort, Quick sort, Merge sort về các yếu tố sau: thời gian chạy, số phép gán và số phép so sánh. </li>
                            <li class="number-list">Hãy viết chương trình cài đặt giải thuật Quick sort, so sánh thời gian chạy giải thuật khi lấy x là phần tử chính giữa dãy, đầu dãy, cuối dãy và không dùng k thuật đệ qui.</li>
                            <li class="number-list">Hãy viết chương trình cài đặt giải thuật Quick sort, so sánh thời gian chạy giải thuật khi lấy x là phần tử chính giữa dãy, đầu dãy, cuối dãy và dùng k thuật đệ qui </li>
                            <li class="number-list">Giả ử cho dãy ban đầu là A : {12, 8, 2, 14, 3, 5, 10, 15, 36}. Hãy sắp xếp dãy đã cho theo quy tắc:  </li>
                            <ul>
                                <li class="letter-list">Các số chẵn (nếu có) có thứ tự t ng dần.</li>
                                <li class="letter-list">Các số lẻ (nếu có) có thứ tự giảm dần. </li>
                                <li class="letter-list">Tính chất chẵn / lẻ tại m i vị trí trong dãy không thay đ i sau khi sắp xếp (tức là trước khi sắp xếp, tại vị trí i của dãy A là số chẵn/lẻ thì tại vị trí i của mảng sau khi sắp xếp cũng là ố chẵn/lẻ).</li>
                            </ul>
                            <li class="number-list">Dựa trên ý tưởng của giải thuật chèn trực tiếp, hãy trình bày ý tưởng cải tiến giải thuật này ao cho độ phức tạp trong trường hợp tốt nhất là O(NlogN).</li>
                            <li class="number-list">Trong ba giải thuật sắp xếp chọn trực tiếp, chèn trực tiếp và n i bọt, giải thuật nào thực hiện sắp xếp nhanh nhất nếu cho một dãy đã có thứ tự, giải thích và cho ví dụ minh họa.</li>
                            <li class="number-list">Hãy đề xuất giải thuật tìm phần tử trung vị (phần tử giữa - median) trong giải thuật sắp xếp Quick sort sao cho hiệu quả nhất với một dãy số nguyên N phần tử.</li>
                            <li class="number-list">Giả sử cho một đa thức P bậc N (0 < N < 100) gồm các số hạng, biết rằng thông tin số hạng bao gồm: </li>
                            <ul>
                                <li class="list">Dấu: âm hoặc dương (quy định 0 là m, 1 là dương)</li>
                                <li class="list">Hệ số: là một số thực</li>
                                <li class="list">Bậc: là một số nguyên (giá trị từ 1 đến 99) </li>
                            </ul>
                            <p class="des">Hãy thực hiện các yêu cầu sau:</p>
                            <ul>
                                <li class="letter-list">Định nghĩa cấu trúc dữ liệu để biểu diễn đa thức P.</li>
                                <li class="letter-list">Áp dụng một giải thuật sắp xếp để sắp xếp các số hạng trong đa thức theo thứ tự t ng dần của bậc. </li>
                            </ul>
                            <li class="number-list">Giả sử cho thông tin một sinh viên, bao gồm: </li>
                            <ul>
                                <li class="list">Mã sinh viên: là một số nguyên dương (qui định là số duy nhất, không trùng) </li>
                                <li class="list">Họ: là một chuỗi</li>
                                <li class="list">Tên: là một chuỗi</li>
                                <li class="list">Ngày, tháng, năm sinh là một số nguyên dương theo đúng qui tắc của ngày tháng n m inh trong thực tế </li>
                                <li class="list">Giới tính: là một số nguyên (qui định: 0 là Nữ, 1: Nam)</li>
                                <li class="list">Điểm trung bình học tập: là một số thực (qui định giá trị từ 0.0 đến 10.0)</li>
                            </ul>
                            <p class="des">Hãy thực hiện các yêu cầu sau:</p>
                            <ul>
                                <li class="letter-list">Định nghĩa cấu trúc dữ liệu để biểu diễn thông tin sinh viên.</li>
                                <li class="letter-list">Viết hàm nhập danh sách N sinh viên, trong đó N nhập từ bàn phím và lưu vào trong fil Sinhvi n.dat, với yêu cầu đảm bảo ràng buộc qui định về miền giá trị ở trên. </li>
                                <li class="letter-list">Áp dụng một giải thuật sắp xếp để sắp xếp danh sách sinh viên theo mã số inh viên t ng dần với thông tin sinh viên đọc từ file trong câu b.</li>
                                <li class="letter-list">Áp dụng một giải thuật sắp xếp để sắp xếp danh sách sinh viên th o điểm trung bình giảm dần với thông tin sinh viên đọc từ file trong câu b. </li>
                                <li class="letter-list">Hiển thị danh sách sinh viên theo kết quả sắp xếp trong câu c, d.</li>
                            </ul>
                            <li class="number-list">Trong các giải thuật trình bày trong chương, có phải sẽ luôn có một giải thuật tốt nhất về thời gian xử lý và không phụ thuộc vào tình trạng dãy số đã cho ban đầu không?. Hãy giải thích và cho ví dụ minh họa. </li>
                            <li class="number-list">Hãy viết chương trình minh họa trực quan hóa các giải thuật sắp xếp.</li>
                        </ul>

                    </div>
                    <div class="tab-pane" id="CHƯƠNG_3">
                        <h1 class="heading1">
                            CHƯƠNG 3
                            DANH SÁCH LIÊN KẾT
                        </h1>
                        <h2 class="heading2" id="3.1">
                            3.1. DANH SÁCH TUYẾN TÍNH
                        </h2>
                        <h3 class="heading3" id="3.1.1">3.1.1. ĐỊNH NGHĨA</h3>
                        <p class="des">
                            Danh sách tuyến tính là dãy gồm 0 hoặc nhiều hơn các phần tử
                            cùng kiểu cho trước: (a1, a2, … aN), N ≥ 0.
                        </p>
                        <p class="des">
                            - ai là phần tử của danh sách.
                        </p>
                        <p class="des">
                            - a1 là phần tử đầu tiên và aN là phần tử cuối cùng.
                        </p>
                        <p class="des">
                            - N là độ dài danh sách, khi N = 0, ta có danh sách r ng.
                        </p>
                        <p class="des">
                            Một tính chất quan trọng của danh sách là các phần tử có thể
                            được sắp xếp tuyến tính theo vị trí của chúng trong danh  ách. Như
                            thế, phần tử ai đi trước phần tử ai+1, phần tử ai+1 đi  au phần tử ai và
                            phần tử ai ở vị trí thứ i.

                        </p>
                        <p class="des">
                            Danh sách là một cấu trúc thường gặp nhất, ví dụ như danh  ách
                            sinh viên, danh sách giảng viên, danh sách nhân viên, danh sách các
                            ngành đào tạo trong một trường đại học,…

                        </p>
                        <img src="img/monhoc/hinh3.1.jpg" alt="" srcset="">
                        <h1 class="heading4" id="3.1.2">
                            3.1.2. Các thao tác trên danh sách
                        </h1>
                        <h1 class="heading5" id="3.1.2.1">
                            3.1.2.1. Tìm kiếm một phần tử trong danh sách
                        </h1>
                        <p class="des">
                            Khi tìm kiếm cần phải biết được thông tin lưu trữ để tìm kiếm.
                            Kết quả của thao tác tìm kiếm là vị trí của phần tử trong danh sách,
                            nếu tìm thấy hoặc là một giá trị mặc định nào đó  ví dụ giá trị 0), nếu
                            không tìm thấy
                        </p>
                        <h1 class="heading6" id="3.1.2.2">
                            3.1.2.2. Thêm một phần tử vào danh sách
                        </h1>
                        <p class="des">
                            Về nguyên tắc, ta có thể thêm phần tử mới vào các vị trí khác
                            nhau trong danh sách, cụ thể là vị trí đầu danh sách, khoảng giữa danh
                            sách hoặc vị trí cuối danh sách. Sau khi hoàn thành thao tác thêm vào
                            thì số phần tử trong danh  ách t ng thêm một phần tử. Chú ý rằng các
                            phần tử liền kề với phần tử thêm vào sẽ bị thay đ i vị trí sau khi thực
                            hiện thao tác thêm.
                        </p>
                        <h1 class="heading7" id="3.1.2.3">
                            3.1.2.3. Loại bỏ một phần tử trong danh sách
                        </h1>
                        <p class="des">
                            Ngược lại với thao tác thêm là thao tác loại bỏ phần tử trong danh
                            sách. Tùy theo nhu cầu mà thao tác loại bỏ phần tử có thể thực hiện
                            theo sau một hay nhiều điều kiện nào đó. Như thế, gắn với thao tác
                            loại bỏ là thao tác tìm kiếm phần tử thỏa mãn điều kiện nào đó và thao
                            tác tìm kiếm sẽ thực hiện trước, và tùy theo kết quả của thao tác tìm
                            kiếm mà thao tác loại bỏ có thể thực hiện hay không. Cụ thể, nếu
                            không tìm thấy phần tử cần loại bỏ (không thỏa mãn điều kiện tìm
                            kiếm đặt ra) thì không thể thực hiện thao tác loại bỏ. Trong trường
                            hợp tìm thấy phần tử cần loại bỏ thì ta thực hiện thao tác loại bỏ, khi
                            đó  ố phần tử trong danh sách giảm đi một phần tử. Chú ý rằng các
                            phần tử đi  au phần tử loại bỏ có thể bị thay đ i vị trí sau khi thực hiện
                            thao tác loại bỏ.

                        </p>
                        <h1 class="heading8" id="3.1.2.4">
                            3.1.2.4. Thay thế một phần tử của danh sách bởi một phần tử khác
                        </h1>
                        <p class="des">
                            Thao tác thực hiện thay thế một phần tử của danh sách bởi một
                            phần tử khác thường được thực hiện khi kết hợp với một hay nhiều
                            điều kiện nào đó liên quan đến giá trị của phần tử đã lưu trữ trong danh sách. Như thế, cũng như thao tác loại bỏ, thao tác thay thế cũng
                            thường gắn với thao tác tìm kiếm trước khi tiến hành thay thế.
                        </p>
                        <h1 class="heading9" id="3.1.2.5">
                            3.1.2.5. Ghép nhiều danh sách thành một danh sách
                        </h1>
                        <p class="des">
                            Thao tác này cũng thường được sử dụng nhằm mục đích tạo ra
                            một danh sách lớn hơn, phục vụ cho một yêu cầu nào đó.  ết quả của
                            thao tác ghép này sẽ là một danh  ách mà trong đó đi  au các phần tử
                            của danh sách thứ nhất sẽ là phần tử của danh sách thứ hai và cứ tiếp
                            tục như thế cho các danh sách còn lại. Xét về mặt số phần tử thì số
                            phần tử của danh sách hợp nhất sẽ là t ng của các danh sách. Trong
                            thao tác này vị trí của phần tử trong danh sách sau khi được ghép
                            chung sẽ có sự thay đ i.
                        </p>
                        <h1 class="heading10" id=3.1.2.6>
                            3.1.2.6. Tách một danh sách thành nhiều danh sách
                        </h1>
                        <p class="des">
                            Ngược lại với thao tác ghép danh sách là thao tác tách danh sách.
                            Với thao tác này một danh  ách ban đầu được tách thành nhiều danh
                            sách nhỏ hơn t y th o yêu cầu. Khi thực hiện thao tác này cần xác
                            định thông tin về vị trí bắt đầu và vị trí kết thúc khi tách danh sách.
                            Xét về mặt số phần tử thì số phần tử của tất cả các danh sách con sẽ
                            bằng t ng phần tử trong danh  ách ban đầu. Trong thao tác này phần
                            tử trong danh sách khi được tách vào các danh sách khác nhau sẽ có vị
                            trí khác nhau.
                        </p>
                        <h1 class="heading11" id="3.1.2.7">
                            3.1.2.7. Sao chép danh sách
                        </h1>
                        <p class="des">
                            Thao tác này thực hiện sao chép một danh sách nguồn thành
                            một danh  ách đích có c ng  ố phần tử và vị trị các phần tử không
                            thay đi.
                        </p>
                        <h1 class="heading12" id="3.1.2.8">
                            3.1.2.8. Sắp thứ tự các phần tử trong danh sách
                        </h1>
                        <p class="des">
                            Với thao tác này, việc sắp thứ tự các phần tử trong danh sách
                            được thực hiện theo một tiêu chí cho trước phụ thuộc vào thông tin và
                            giá trị của các thông tin đã lưu trữ trong phần tử. Kết quả của thao tác
                            này là sự thay đ i vị trí của các phần tử trong danh  ách ban đầu theo
                            một tiêu chí xác định. Thao tác này không làm thay đ i số phần tử
                            trong danh sách. Có nhiều phương pháp để cài đặt cho thao tác sắp thứ tự và t y th o phương pháp  ử dụng mà có độ phức tạp tính toán và
                            hiệu quả riêng. Việc chọn phương pháp nào phụ thuộc vào đặc điểm,
                            tính chất và yêu cầu của thông tin lưu trữ trong danh sách và bài toán
                            cần giải quyết.
                        </p>
                        <h1 class="heading13" id="3.1.3">3.1.3. Biểu diễn danh sách dưới dạng mảng</h1>
                        <p class="des">
                            Để biểu diễn danh  ách dưới dạng mảng, ta lưu các phần tử của
                            danh sách vào các ô liên tiếp của mảng.
                        </p>
                        <p class="des">
                            Danh sách sẽ gồm hai thành phần: thành phần 1 là mảng các phần
                            tử và thành phần 2 cho biết vị trí của phần tử cuối cùng trong
                            danh sách.
                        </p>
                        <p class="des">
                            Về mặt ưu điểm, cách biểu diễn này thuận lợi trong việc truy
                            xuất nhanh đến các phần tử trong danh sách. Tuy nhiên, hạn chế
                            lớn nhất trong cách biểu diễn này đó là không linh hoạt về mặt kích
                            thước danh sách trong mọi trường hợp, do ta không biết trước số
                            phần tử cần thiết phải có trong danh  ách, thông thường ta phải
                            khai báo kích thước tối đa cho mảng để dự phòng, khi đó  ẽ dẫn
                            đến tình trạng lãng phí bộ nhớ. Danh sách liên kết là một cách để
                            khắc phục hạn chế, tạo sự linh hoạt.
                        </p>
                        <h1 class="heading14" id="3.2">
                            3.2. DANH SÁCH LIÊN KẾT
                        </h1>
                        <h1 class="heading15" id="3.2.1">
                            3.2.1. Định nghĩa
                        </h1>
                        <p class="des">
                            Cho T là một kiểu được định nghĩa trước, kiểu danh sách Tx
                            gồm các phần tử thuộc kiểu T được định nghĩa là  Tx = < Vx,
                            Ox>, trong đó:
                        </p>
                        <p class="des">
                            - Vx = {tập hợp có thứ tự các phần tử có kiểu dữ liệu T được liên
                            kết với nhau theo trình tự tuyến tính}
                        </p>
                        <p class="des">
                            - Ox = {Tạo danh sách; Tìm một phần tử trong danh sách; Chèn
                            một phần tử vào danh sách; Loại một phần tử khỏi danh sách; Tìm
                            kiếm; Sắp xếp danh sách; ...}
                        </p>
                        <p class="des">
                            Mối liên hệ giữa các phần tử trong danh  ách được thể hiện tường
                            minh: m i phần tử ngoài các thông tin về bản thân còn chứa một địa
                            chỉ đến phần tử kế trong danh  ách nên được gọi là danh sách liên kết.
                        </p>
                        <p class="des">
                            Do có liên kết tường minh, với hình thức này các phần tử trong
                            danh sách không cần lưu trữ kế cận trong bộ nhớ nên khắc phục được
                            các khuyết điểm của hình thức t chức mảng, nhưng việc truy xuất
                            đến một phần tử đòi hỏi phải thực hiện truy xuất qua một số phần tử
                            khác.
                        </p>
                        <p class="des">
                            Có nhiều kiểu t chức liên kết giữa các phần tử trong danh sách:
                        </p>
                        <p class="des">
                            - Danh sách liên kết đơn là danh  ách mà m i phần tử trong danh
                            sách chỉ liên kết với phần tử đứng sau nó trong danh sách.
                        </p>
                        <img src="img/monhoc/hinhanh1.jpg" alt="" srcset="">
                        <p class="des">
                            - Danh sách liên kết kép là danh sách mà m i phần tử trong danh
                            sách liên kết với phần tử đứng trước và sau nó bằng hai mối liên kết.
                        </p>
                        <img src="img/monhoc/hinhanh2.jpg" alt="" srcset="">
                        <p class="des">
                            - Danh sách liên kết vòng là danh sách mà phần tử đứng cuối
                            danh sách lại liên kết với phần tử đầu danh sách theo dạng danh sách
                            liên kết đơn hoặc danh sác kép.
                        </p>
                        <img src="./img/monhoc/hinhanh3.jpg" alt="" srcset="">
                        <p class="des">
                            Hình thức liên kết này cho phép các thao tác thêm, hủy trên danh
                            sách được thực hiện dễ dàng, phản ánh được bản chất linh động của danh sách.
                        </p>

                    </div>
                    <div class="tab-pane" id="CHƯƠNG_4">

                        <h1 class="heading1 tab-pane">
                            CHƯƠNG 4
                            NGĂN XẾP  HÀNG ĐỢI
                        </h1>
                        <h2 class="heading2">
                            4.1. NGĂN XẾP
                        </h2>
                        <h3 class="heading3">
                            4.1.1. Định nghĩa
                        </h3>
                        <p class="des">
                            Ngăn xếp (stack) là một cấu trúc dữ liệu trừu tượng hoạt động
                            theo nguyên lý "vào sa  ra  rước" (Last In First Out – LIFO,  nghĩa là
                            dữ liệu được nạp vào ng n xếp trước sẽ được xử lý sau cùng và dữ
                            liệu được nạp vào sau cùng lại được xử lý đầu tiên).
                        </p>
                        <p class="des">
                            Nói một cách khác, ng n xếp là một cấu trúc dữ liệu dạng thùng
                            chứa của các phần tử và trên đó có hai thao tác cơ bản: Push và
                            Pop. Thao tác Push b  sung một phần tử vào đỉnh của ng n xếp, nghĩa
                            là sau các phần tử đã có trong ng n xếp. Trong khi đó, thao tác
                            Pop lấy ra và trả về phần tử đang đứng ở đỉnh của ng n xếp.
                        </p>
                        <p class="des">
                            Trong ngăn xếp, các đối tượng có thể được thêm vào bất kỳ lúc
                            nào nhưng chỉ có đối tượng thêm vào sau cùng mới được phép lấy ra
                            khỏi ng n xếp
                        </p>
                        <p class="des">
                            Hình minh họa dưới đây mô tả cách thức hoạt động của ng n xếp
                            với hai thao tác Push và Pop trên ngăn xếp các phần tử là các số
                            nguyên.
                        </p>
                        <img src="./img/monhoc/chuong4.1.jpg" alt="" srcset="">
                        <h3 class="heading3">
                            4.1.2 Các thao tác trên ngăn xếp
                        </h3>
                        <p class="des">
                            Các thao tác trên ngăn xếp bao gồm :
                        </p>
                        <p class="des">
                            - Thao tác Push(object): thêm một phần tử vào ngăn xếp
                        </p>
                        <p class="des">
                            -Thao tác Pop(): lấy một phần tử ra khỏi ng n xếp và trả lại giá trị phần tử
                        </p>
                        <p class="des">
                            Thao tác Top(): trả lại vị trí phần tử nạp sau cùng vào ngăn xếp
                        </p>
                        <p class="des">
                            -Thao tác Size(): trả lại số lượng phần tử được lưu trong ngăn xếp
                        </p>
                        <p class="des">
                            Thao tác isEmpty(): kiểm tra xem có phải ngăn xếp rỗng không.
                        </p>
                        <h3 class="heading3">
                            4.1.3 Ứng dụng với ngăn xếp
                        </h3>
                        <p class="des">
                            Dựa theo cách thức t  chức, cơ chế hoạt động của ng n xếp, ta có
                            thể xây dựng nhiều ứng dụng đa dạng, như
                        <p class="des">
                            -Xây dựng ứng dụng theo dõi lịch sử duyệt trang trong trình
                            duyệt web.
                        </p>
                        <p class="des">
                            -Xây dựng chức n ng Undo trong phần mềm soạn thảo v n bản
                            hoặc các phần mềm khác cần chức n ng phục hồi lại một thao
                            tác đã thực hiện trước đó
                        <p class="des">
                            -Xây dựng ứng dụng đổi cơ số
                        </p>
                        <p class="des">
                            -Xây dựng ứng dụng trong cài đặt chương trình dịch.
                        </p>
                        <p class="des">
                            -Xây dựng chương trình kiểm tra tính hợp lệ của các dấu ngoặc
                            trong biểu thức.
                        </p>
                        <p class="des">
                            -Sử dụng trong khử đệ quy khi lập trình.
                        </p>
                        <p class="des">
                            - …
                        </p>
                        <h3 class="heading3">
                            4.1.4 Cài đặt ngăn xếp
                        </h3>
                        <p class="des">
                            Có hai cách cài đặt ngăn xếp:
                        </p>
                        <p class="des">
                            -Cài đặt ngăn xếp dùng mảng
                        </p>
                        <img src="img/monhoc/hinh4.1.4.1.jpg" alt="" srcset="">
                        <p class="des">
                            Cách đơn giản nhất để cài đặt ng n xếp là dùng mảng. Ta nạp các
                            phần tử theo thứ tự từ trái sang phải. Có biến lưu giữ chỉ số của phần
                            tử ở đầu ngăn xếp.Thao tác cài đặt ng n xếp dùng mảng được thực
                            hiện qua các bước sau :
                        </p>
                        <p class="des">
                            Bước 1:  Khai báo cấu trúc dữ liệu của ngăn xếp
                            typedef struct tagStack
                            { int a[max];
                            int t;
                            }Stack;
                        <p class="des">
                            Bước 2 : Viết các hàm thực hiện các  hao  ác  rên ngăn xếp, bao
                            gồm các thao tác chính :
                             Thao tác khởi tạo ngăn xếp
                             Thao tác kiểm tra ngăn xếp có rỗng không
                             Thao tác thêm phần tử vào ng n xếp
                             Thao tác kiểm tra ng n xếp có đầy hay không
                             Thao tác lấy phần tử ra khỏi ngăn xếp -
                            Hàm khởi tạo ngăn xếp
                            void CreateStack(Stack &s)
                            {
                            s.t=-1;
                        </p>
                        <Pp class="des">
                            -Hàm kiểm  ra ngăn xếp có đầy hay không ?
                        </Pp>
                        <p class="des">
                            int IsFull(Stack s)
                            {   if(s.t>=max)
                            return 1;
                            else
                            return 0;
                            } -  Hàm  thêm  phần  tử vào ngăn xếp
                            int Push(Stack &s, int x)
                            {
                            if (IsFull(s)==0)
                            {   s.t++;
                            s.a[s.t]=x;
                            return 1;
                            }
                        </p>
                        <p class="des">
                            else
                            return 0;
                            } -  Hàm lấy  hần  ử ra khỏi ngăn xế
                            int Pop(Stack &s, int &x)
                            {
                            if (IsEmpty(s)==0)
                            { x=s.a[s.t];
                            s.t--;
                            return 1;
                            }
                            else return 0;
                            }
                        </p>
                        <h3 class="heading3">
                            4.1.4.2.  Cài đặt ngăn xếp dùng danh sách liên kết
                        </h3>
                        <p class="des">
                            Thao tác cài đặt ng n xếp dùng danh sách liên kết được thực hiện
                            qua các bước sau
                        </p>
                        <p class="des">
                            Bước 1:  Khai báo cấu trúc dữ liệu của ngăn xếp
                            struct StackNode
                            {  float item;
                            StackNode *next;
                            };
                            struct Stack
                            { StackNode *top;
                            };
                        </p>
                        <p class="des">
                            Bước 2 : Viết các hàm thực hiện các  hao  ác  rên ngăn xếp,cũng
                            bao gồm các thao  tác như  hực hiện trên cấu trúc mảng
                        </p>
                        <p class="des">
                             Thao tác khởi tạo ngăn xếp
                        </p>
                        <p class="des">
                             Thao tác kiểm tra ng n xếp có rỗng không
                        </p>
                        <p class="des">
                             Thao tác thêm phần tử vào ngăn xếp
                        </p>
                        <p class="des">
                             Thao tác kiểm tra ngăn xếp có đầy hay không
                        </p>
                        <p class="des">
                             Thao tác lấy phần tử ra khỏi ngăn xếp
                        </p>
                        <p class="des">
                            -  Hàm khởi tạo ngăn xếp
                            Stack *StackConstruct ()
                            {
                            Stack *s;
                            s = (Stack *)malloc (sizeof (Stack));
                            if (s == NULL)
                            return NULL;
                            s->top = NULL;
                            return s;
                            }
                        </p>
                        <p class="des">
                            -  Hàm hủy ngăn xếp
                            void StackDestroy (Stack *s)
                            {
                            while (!SatckEmpty(s))
                            { StackPop(s);
                            free (s);
                            }
                            }
                        </p>
                        <p class="des">
                            - Hàm kiểm tra ngăn xếp rỗng hay không
                            int StackEmpty (const Stack *s)
                            {
                            return (s->top == NULL);
                            } -  Hàm kiểm tra ngăn xếp có đầy hay không
                            int StackFull()
                            {
                            }
                            getch();
                            return 1
                        </p>
                        <p class="des">
                            - Hàm đưa  hần tử vào ngăn xếp
                            int StackPush (Stack *s, float item)
                            {
                            StackNode *node;
                            node = (StackNode *)malloc(sizeof(StackNode));
                            if (node == NULL)
                            {
                            }
                            StackFull();
                            return 1;  // tràn ngăn xếp
                            node->item = item;
                            node->next = s->top;
                        </p>
                        <p class="des">
                            s->top = node;
                            return 0;
                            } - Hàm lấy phần tử ra khỏi ngăn xếp
                        </p>
                        <p class="des">
                            float StackPop (Stack *s)
                            {
                            float item;
                            StackNode *node;
                            if (StackEmpty (s))
                            return NULL;
                            node = s->top;
                            item = node->item;
                            s->top = node->next;
                            free (node);
                            return item;
                            <h2 class="heading2">
                                4.2. HÀNG ĐỢI
                            </h2>
                            <h3 class="heading3">
                                4.2.1. Định nghĩa
                            </h3>
                        <p class="des">
                            Hàng đợi (queue) là một cấu trúc dữ liệu dùng để chứa các đối
                            tượng dữ liệu, hoạt động theo cơ chế FIFO (First In First Out - nghĩa
                            là dữ liệu được nạp vào hàng đợi trước sẽ được xử lý trước).
                        </p>
                        <p class="des">
                            Các đối tượng có thể được thêm vào hàng đợi bất kỳ lúc nào và ở
                            vị trí cuối hàng đợi, chỉ có đối tượng thêm vào đầu tiên mới được
                            phép lấy ra khỏi hàng đợi đầu tiên. Thao tác thêm vào và lấy một đối
                            tượng ra khỏi hàng đợi được gọi là "enqueue" và "dequeue".
                        </p>

                        </p>
                        <img src="img/monhoc/chuong4.2.jpg" alt="" srcset="">
                        <p class="des">
                            Cấu trúc dữ liệu hàng đợi có nhiều ứng dụng giúp h  trợ giải
                            quyết các bài toán trong tin học như: khử đệ quy, lưu vết các quá
                            trình tìm kiếm theo chiều rộng, quay lui, vét cạn, t  chức quản lý và
                            phân phối tiến trình trong các hệ điều hành, t  chức bộ đệm bàn
                            phím….
                        </p>
                        <h3 class="heading3">
                            4.2.2. các thao tác trên hàng dợi
                        </h3>
                        <p class="des">
                            Tương tự như ng n xếp, hàng đợi h  trợ các thao tác:
                        </p>
                        <p class="des">
                             EnQueue (obj)  thêm đối tượng obj vào cuối hàng đợi.
                        </p>
                        <p class="des">
                             DeQueue(): lấy đối tượng ở đầu hàng đợi ra khỏi hàng đợi và
                            trả về giá trị của nó. Nếu hàng đợi r ng thì lỗi sẽ xảy ra.
                        </p>
                        <p class="des">
                             IsEmpty(): kiểm tra xem hàng đợi có rỗng không.
                        </p>
                        <p class="des">
                             Front(): trả về giá trị của phần tử nằm ở đầu hàng đợi mà
                            không hủy nó. Nếu hàng đợi rỗng thì lỗi sẽ xảy ra.
                        </p>
                        <h3 class="heading3">
                            4.2.3. cài đặt hàng đợi
                        </h3>
                        <p class="des">
                            Có 2 cách cài đặt hàng đợi: cài đặt hàng đợi dùng mảngvà dùng
                            danh sách liên kết.
                        </p>
                        <h3 class="heading3">
                            4.2.3.1.  Cài đặt hàng đợi sử dụng mảng
                        </h3>
                        <p class="des">
                            a. Sử dụng mảng thông thường
                        <p class="des">
                            Bước 1:  Khai báo cấu trúc dữ liệu hàng đợi - Khai báo mảng các phần tử
                            #define MAX 20 // giả sử dùng mảng gồm 20 phần tử
                        </p>

                        </p>
                        <p class="des">
                            - Khai báo kiểu dữ liệu lưu trữ trong hàng đợi
                        </p>
                        <p class="des">
                            typedef <Kiểu dữ liệu> El_type;
                        </p>
                        <p class="des">
                            - Định nghĩa cấu trúc dữ liệu hàng đợi Queue
                        </p>
                        <p class="des">
                            - Định nghĩa cấu trúc dữ liệu hàng đợi Queue
                        </p>
                        <p class="des">
                            typedef struct Queue
                            {
                            El_type el[MAX];
                            int front;
                            int rear;
                            } Queue;
                        </p>
                        <p class="des">
                            Bước 2 : Viết các hàm thực hiện các  hao  ác  rên hàng đợi
                        </p>
                        <p class="des">
                            - Hàm khởi tạo hàng đợi ban đầu
                        </p>
                        <p class="des">
                            Eltype *initQ(Queue *q)
                            {
                            q = (Queue *)malloc(sizeof(Queue));
                            if (q != NULL)
                            { q->front = -1;
                            q->rear = -1;
                            }
                            return q;
                            }
                        </p>
                        <p class="des">
                            - Hàm kiểm  ra xem hàng đợi có rỗng không?
                        </p>
                        <p class="des">
                            int isEmpty(Queue *q)
                            {
                            return (q->front == -1);
                            }
                        <p class="des">
                            - Hàm kiểm tra xem hàng đợi có đầy không?
                        </p>
                        <p class="des">
                            int isFull(Queue q)
                            {
                            return (q.rear-q.front+1 == MAX);
                            }
                            - Hàm thêm một phần tử vào hàng đợi
                            void enQ(El_type new_el, Queue *q)
                            {
                            if (!isFull(q))
                            { if (isEmpty(q))
                            q->front = q->front+1;
                            q->rear = q->rear+1;
                            q->el[q->rear] = new_el;
                            }
                            else
                            printf("Hàng đợi đầy.\n");
                            }
                        </p>
                        <p class="des">
                            - Hàm xóa một phần tử khỏi hàng đợi
                        </p>
                        <p class="des">
                            void deQ(Queue *q)
                            {
                            if (!isEmpty(q))
                            119

                            q->front = q->front+1;
                            else
                            printf("Hàng đợi trống.\n");
                            }

                        </p>
                        <p class="des">
                            Nhận xét :
                            Qua mỗi lần xóa, phần sử dụng được của mảng sẽ giảm đi  (do giá
                            trị biến front t ng lên). Trong trường hợp đó, có thể khắc phục bằng
                            cách sử dụng mảng vòng.
                        </p>
                        <h1 class="heading1">
                            b. Sử dụng mảng vòng
                        </h1>
                        <p class="des">
                            - Hàm khởi tạo hàng đợi
                        </p>
                        <p class="des">
                            Eltype *initQ(Queue *q)
                            {
                            q = (Queue *)malloc(sizeof(Queue));
                            if (q != NULL)
                            { q->front = -1;
                            q->rear = -1;
                            }
                            return q;
                            } - Hàm kiểm  ra xem hàng đợi có rỗng không?
                            int empty_queue(queue q)
                            {
                            return q.front==-1;
                            }
                        </p>
                        <p class="des">
                            - Thao tác kiểm  ra xem hàng đợi có đầy không?
                        </p>
                        <p class="des">
                            int full_queue(queue q)
                            {
                            return ((q.rear-q.front+1) % maxlength==0);
                            }
                        </p>
                        <p class="des">
                            - Hàm đưa  hêm một phần tử vào hàng đợi
                        </p>
                        <p class="des">
                            void enqueue(elementtype x,queue *q)
                            {
                            if (!full_queue(*q))
                            {   if (empty_queue(*q))
                            q->front=0;
                            q->rear=(q->rear+1) % maxlength;
                            q->data[q->rear]=x;
                            }
                            el   printf ("Hàng đợi đầy!");
                            }
                        </p>
                        <p class="des">
                            -Hàm xóa một phần tử khỏi hàng đợi
                        </p>
                        <p class="des">
                            void dequeue(queue *q)
                            {
                            if (!empty_queue(*q))
                            {  if (q->front==q->rear)
                            makenull_queue(q);
                            else
                            q->front=(q->front+1) % maxlength;
                            }
                            else   printf "Hàng đợi rỗng";
                            }
                        </p>
                        <p class="des">
                            Nhận xét :
                        </p>
                        <p class="des">
                            Mặc d  phương pháp  ử dụng mảng vòng có thể tận dùng toàn bộ
                            các mảng đã được cấp pháp ban đầu nhưng khi mảng đầy thì không
                            thể thêm phần tử vào hàng được nữa. Trong trường hợp này, có thể
                            khắc phục bằng cách sử dụng danh sách liên kết để mở rộng.
                        </p>
                        <p class="des">
                            4.2.3.2. c ài đặt hàng đợi dùng danh sách liên kết
                        </p>
                        <p class="des">
                            Bước 1:  Khai báo cấu trúc dữ liệu hàng đợi
                        </p>
                        <p class="des">
                            - Khai báo kiểu dữ liệu lưu trữ trong hàng đợi
                        </p>
                        <p class="des">
                            - Định nghĩa cấu trúc dữ liệu hàng đợi Queue
                        </p>
                        <p class="des">
                            typedef struct node
                            { elementtype data;
                            node* next;
                            };
                            typedef node* position;
                            typedef struct queue
                            {  position front,rear;
                            };
                        </p>
                        <p class="des">
                            Bước 2 : Viết các hàm thực hiện các  hao  ác  rên hàng đợi
                        </p>
                        <p class="des">
                            - Hàm khởi tạo hàng đợi
                        </p>
                        <p class="des">
                            void makenull_queue(queue *q)
                            { q->front=(node*)malloc(sizeof(node));
                            q->front->next=NULL;
                            q->rear=q->front;
                            122

                            }
                            - Hàm xem hàng đợi có rỗng không?
                            int empty_queue(queue q)
                            {
                            return (q.front==q.rear);
                            }
                        </p>
                        <p class="des">
                            - Hàm đưa  hêm một phần tử vào hàng đợi
                        </p>
                        <p class="des">
                            void enqueue(elementtype x, queue *q)
                            {
                            q->rear->next=(node*)malloc(sizeof(node));
                            q->rear=q->rear->next;
                            q->rear->data=x;
                            q->rear->next=NULL;
                            }
                        </p>
                        <p class="des">
                            - Hàm xóa một phần tử khỏi hàng đợi
                        </p>
                        <p class="des">
                            void dequeue(queue *q)
                            {
                            position t;
                            t=q->front;
                            q->front=q->front->next;
                            free(t);
                            }
                        </p>
                        <p class="des">
                            Nhận xét :
                        </p>
                        <p class="des">
                            Khi sử dụng hàng đợi bằng cách cài đặt thông qua danh sách liên
                            kết giúp khắc phục được tình trạng đầy của việc sử dụng mảng để cài
                            đặt hàng đợi, tuy nhiên thao tác trên danh sách phức tạp hơn  o với
                            dùng mảng.
                        </p>
                        <h1 class="heading1">
                            BÀI TẬP CHƯƠNG 4
                        </h1>
                        <p class="des">
                            1.
                            Giả sử cho hàm push(a) là hàm thực hiện nạp a vào ng n xếp và
                            hàm pop() là hàm lấy phần tử ra khỏi ng n xếp. Giả sử cho dãy
                            thao tác  au đ y, biết rằng ng n xếp ban đầu được khởi tạo r ng :
                            push(5), push(3), pop(), push(2), push(8), pop(), pop(), pop(),
                            push(9), push(1), pop(), push(7), push(6), pop(), pop(), push(4),
                            pop(), pop().
                            Hãy viết ra dãy phần tử của danh của ng n xếp (chỉ rõ vị trí đầu
                            ng n xếp) sau khi thực hiện m i thao tác.
                        </p>
                        <p class="des">
                            2.
                            Giả sử cho hàm enq(a) là hàm thực hiện nạp a vào hàng đợi và
                            hàm deq() là hàm thực hiện lấy phần tử ra khỏi hàng đợi. Giả sử
                            cho dãy các thao tác  au đ y, biết rằng hàng đợi ban đầu được
                            khởi tạo rỗng:
                        </p>
                        <p class="des">
                            enq(5), enq(3), deq(), enq(2), enq(8), deq(), enq(9), enq(1), deq(),
                            enq(7), enq(6), deq(), deq(). enq(4), deq(), deq().
                            Hãy viết ra dãy các phần tử của hàng đợi (chỉ rõ vị trí đầu và cuối
                            của hàng đợi) sau khi thực hiện m i thao tác.
                        </p>
                        <p class="des">
                            3.Hãy trình bày cách sử dụng ng n xếp để chuyển biểu thức dạng
                            trung tố  au đ y về dạng biểu thức hậu tố:
                            a. a – b * c ^ d + f
                            b. 1 + 2 + 3 * 4 + 5 – 6 * 7 + 8
                        </p>
                        <p class="des">
                            4.
                            Hãy trình bày cách tính giá trị của biểu thức hậu tố  au đ y nhờ
                            sử dụng ng n xếp:
                            a. 1 2 + 3 1 + * 1 1 + 1 + /
                            b. 3 4 + 3 5 + * 7 + 8 *
                        </p>
                        <p class="des">
                            5.Viết chương trình nhập vào một số nguyên không âm bất kỳ, sau
                            đó hiển thị lên màn hình số đảo ngược thứ tự của số nguyên vừa
                            nhập vào (ví dụ: nếu nhập số 12567, hiển thị lên màn hình số
                            76521) bằng cách:
                        </p>
                        <p class="des">
                            a. Sử dụng ng n xếp
                            b. Sử dụng hàng đợi
                        </p>
                        <p class="des">
                            6.Viết chương trình chuyển đ i một số nguyên N trong hệ thập
                            phân (hệ 10) sang biểu diễn ở các hệ sau, sử dụng ng n xếp:
                            a. Hệ nhị phân (hệ 2)
                            b. Hệ thập lục phân (hệ 16)
                            c. Hệ bát phân (hệ 8)
                        </p>
                        <p class="des">
                            7.Hãy viết chương trình mô phỏng cho bài toán  Tháp Hà Nội
                            bằng cách sử dụng ng n xếp.
                            Có thể vận dụng ng n xếp hoặc
                        </p>
                        <p class="des">
                            8.Có thể vận dụng ng n xếp hoặc hàng đợi để khử đệ quy trong giải
                            thuật sắp xếp Quick sort không? Nếu có giải thích vì sao ?
                        </p>
                        <p class="des">
                            9.Có thể vận dụng ng n xếp hoặc hàng đợi để khử đệ quy trong giải
                            thuật sắp xếp Merge sort không? Nếu có giải thích vì sao ?
                        </p>
                        <p class="des">
                            10.Viết chương trình tìm tất cả các cặp dấu ngoặc tương ứng trong
                            một chương trình viết bằng ngôn ngữ C/C++.
                        </p>


                    </div>
                    <div class="tab-pane" id="CHƯƠNG_5">
                        <h1 class="heading1 tab-pane">
                            CHƯƠNG 5
                            CÂY
                        </h1>
                        <h2 class="heading2">5.1. ĐỊNH NGHĨA VÀ C C KH I NIỆM</h2>
                        <h3 class="heading3">5.1.1 Định nghĩa ây</h3>
                        <p class="des">
                            y được định nghĩa là tập hợp hữu hạn các nút, được t chức
                            theo cấu trúc phân cấp, trong đó có một nút đặc biệt được gọi là nút
                            gốc (root) và tập hợp các nút còn lại nối với nút gốc thông qua các
                            nhánh trên cây gọi là các nút con và các nút lá. Nút lá là nút tận cùng
                            của cây.
                        </p>
                        <p class="des">
                            Hình bên dưới là cấu trúc t chức của c y, trong đó R là nút gốc,
                            R1, R2,..Rk là các nút con của nút gốc R, các nút T1, T2, T3 là các nút
                            lá. y trong hình bên dưới là cây bao gồm k nhánh.
                        </p>
                        <img style="width: 100%;" src="./img/monhoc/pic1.jpg" alt="">
                        <p class="des --center"><b>Hình 5.1.</b> Cấu trúc cây</p>
                        <p class="des">Một số ví dụ hình ảnh của cấu trúc cây trong thực tế:</p>
                        <img style="width: 100%;" src="./img/monhoc/pic2.jpg" alt="">
                        <p class="des --center"><b>Hình 5.2.</b> Cây gia phả</p>
                        <img style="width: 100%;" src="./img/monhoc/pic3.jpg" alt="">
                        <p class="des --center"><b>Hình 5.3.</b> Cây cấu trúc t chức trong một công ty</p>
                        <img style="width: 100%;" src="./img/monhoc/pic4.jpg" alt="">
                        <p class="des --center">
                            <b>Hình 5.4.</b> Cây cấu trúc t chức các chương mục trong một cuốn sách
                        </p>
                        <h3 class="heading3">5.1.2. Các khái niệm trên cây</h3>
                        <p class="des">
                            - Nút gốc – root: Nút gốc là nút trên cùng của cây theo thứ tự
                            phân cấp trong c y. Điều đó có nghĩa là nếu một nút được gọi là nút
                            gốc thì nút này không có nút nào ở trên nó trong phân cấp của cây.
                        </p>
                        <p class="des">- Nút lá (leaf): Một nút không có nút con được gọi là nút lá</p>
                        <p class="des">
                            - Nút con (child): Một nút gọi là nút con khi mà trên nó có một
                            nút khác theo thứ tự phân cấp
                        </p>
                        <p class="des">
                            - Nút cha (parent): Một nút được gọi là nút cha nếu tồn tại một
                            nút là nút con của nó theo thứ tự phân cấp
                        </p>
                        <p class="des">
                            - Tổ tiên (ancestors) và Hậu duệ (descendants): Nếu có đường đi
                            từ nút a đến nút b, thì nút a được gọi là nút t tiên (ancestor) của b,
                            còn b được gọi là nút hậu duệ (descendant) của nút a.
                        </p>
                        <p class="des">
                            - Nút anh em (sibling): Các nút có cùng nút cha được gọi là nút
                            anh em.
                        </p>
                        <p class="des">
                            - Chiều cao (height): Chiều cao của nút trên cây bằng độ dài
                            đường đi dài nhất từ nút đó đến lá cộng 1
                        </p>
                        <p class="des">
                            - Đường đi (path): Nếu n<sub>1</sub>, n<sub>2</sub>, …, nk là dãy nút trên cây
                            sao cho n<sub>i</sub>
                            là cha của n<sub>i + 1</sub> với 1 ≤ i ≤ k, thì dãy này được gọi là đường đi từ nút
                            n<sub>1</sub>
                            đến n<sub>k</sub>.
                        </p>
                        <p class="des">
                            - Độ dài (length) của đường đi bằng số lượng nút trên đường đi
                            trừ bớt đi 1. Như vậy, đường đi độ dài 0 là đường đi từ một nút đến
                            chính nó.
                        </p>
                        <p class="des">
                            - Độ sâu/ mức (depth/level) độ sâu của nút là độ dài của đường
                            đi duy nhất từ gốc cộng thêm 1
                        </p>
                        <p class="des">
                            - Cây con (subtree) của một cây là một nút cùng với tất cả các
                            hậu duệ của nó.
                        </p>
                        <img style="width: 100%;" src="./img/monhoc/pic5.jpg" alt="">
                        <p class="des --center">
                            <b>Hình 5.5.</b>Ví dụ một cây con b và các nút con của cây b: e, f, i, j
                        </p>
                        <img style="width: 100%;" src="./img/monhoc/pic6.jpg" alt="">
                        <p class="des --center">
                            <b>Hình 5.6.</b>Đường đi trên c y, đường đi 1: từ a qua b, qua f và đến
                            i
                        </p>
                        <img style="width: 100%;" src="./img/monhoc/pic7.jpg" alt="">
                        <p class="des --center"><b>Hình 5.7.</b>Chiều cao và độ sâu trên cây</p>
                        <h3 class="heading3">Hình 5.1.3 Cây có thứ tự</h3>
                        <p class="des">
                            Trên cây, các nút được sắp xếp ở các vị trí khác nhau và từ đó
                            chúng ta có các cây khác nhau.Ví dụ dưới đây minh họa hai cây
                            khác nhau.
                        </p>
                        <img style="width: 100%;" src="./img/monhoc/pic8.jpg" alt="">
                        <p class="des --center"><b>Hình 5.8.</b>Ví dụ hai cây bố trí các nút ở vị trí khác nhau </p>
                        <p class="des">
                            Cây với các nút được sắp xếp có thứ tự được gọi là cây có thứ tự, ta sẽ xét chủ
                            yếu là cây có thứ tự. Vì vậy, tiếp theo đây thuật ngữ cây
                            là chỉ để chỉ cây có thứ tự. Khi muốn khẳng định không quan tâm đến
                            thứ tự, ta sẽ phải nói rõ là cây không có thứ tự.
                        </p>
                        <h3 class="heading3">5.1.4 Duyệt theo thứ tự</h3>
                        <p class="des">Có ba cách để duyệt cây theo thứ tự là thứ tự trước, giữa và sau.</p>
                        <b style="line-height: 0px;" class="des">Duyệt theo thứ tự trước</b>
                        <h3 style="margin: 0;">
                            Duyệt theo thứ tự trước (Preorder Traversal) của các nút thuộc cây
                            <br>T :
                        </h3>
                        <p class="des">- Gốc R của T </p>
                        <p class="des">- Tiếp đến là các nút của T1 (là con của nút R) theo thứ tự trước</p>
                        <p class="des">- Sau đó là các nút của T2 (là con của nút R) theo thứ tự trước;</p>
                        <p class="des">- …</p>
                        <p class="des">
                            - Và cuối cùng là các nút của Tk (là con của nút R) theo thứ
                            tự trước.
                        </p>
                        <i class="des">Thuật toán duyệt theo thứ tự rước</i>
                        <p class="des">void PREORDER (nodeT r)</p>
                        <p class="des">{</p>
                        <p class="des">Xuất ra giá trị của nút R;</p>
                        <p class="des --center">
                            Vòng lặp (mỗi nút con C của nút gốc R, nếu có, theo thứ tự
                            từ trái sang) thực hiện :
                        </p>
                        <p class="des"> }</p>
                        <b class="des">Duyệt theo thứ tự sao</b>
                        <h3 style="margin: 0;">Duyệt theo thứ tự sau (Postorder Traversal) của các nút của cây T:</h3>
                        <p class="des">- Các nút của T1 theo thứ tự sau;</p>
                        <p class="des">- Tiếp đến là các nút của T2 theo thứ tự sau;</p>
                        <p class="des">- …;</p>
                        <p class="des">- Các nút của Tk theo thứ tự sau;</p>
                        <p class="des">- Sau cùng là nút gốc R.</p>
                        <p class="des">Thuật toán duyệt theo thứ tự sau</p>
                        <p class="des">void POSORDER (nodeT r)</p>
                        <p class="des">{</p>
                        <p class="des">Xuất ra giá trị của nút R;</p>
                        <p class="des">
                            Vòng lặp (mỗi nút con C của nút gốc R, nếu có, theo thứ tự
                            từ trái sang) thực hiện :
                        </p>
                        <p class="des">Gọi hàm PREORDER(C);</p>
                        <p class="des"> }</p>
                        <b class="des">Duyệt theo thứ tự giữa</b>
                        <h3 style="margin: 0;">Duyệt theo thứ tự giữa (Inorder Traversal) của các nút của cây T :</h3>
                        <p class="des">- Các nút của T1 theo thứ tự giữa;</p>
                        <p class="des">- Tiếp đến là nút gốc R.</p>
                        <p class="des">
                            - Tiếp theo là các nút của T<sub>2</sub>, …, T<sub>k</sub>, m i nhóm nút được xếp
                            theo thứ tự giữa.
                        </p>
                        <p class="des">void INORDER (nodeT r)</p>
                        <p class="des"> {</p>
                        <p class="des">Nếu (R là lá)<br>
                        <p style="margin-left: 30px;" class="des">Xuất ra giá trị của nút R;</p>
                        </p>
                        <p class="des">Ngược lại</p>
                        <p style="margin-left: 50px;" class="des --center">{ Gọi hàm INORDER (con trái nhất của R);</p>
                        <p style="margin-left: 50px;" class="des">Xuất ra giá trị của nút R;</p>
                        <p style="margin-left: 50px;" class="des --center">
                            Vòng lặp (m i nút con của nút R, ngoại trừ con trái
                            nhất, theo thứ tự từ trái sang) thực hiện :
                        </p>
                        <p style="margin-left: 70px;" class="des">Gọi hàm INORDER (c);</p>
                        <p style="margin-left: 50px;" class="des"> }</p>
                        <p class="des"> }</p>
                        <p class="des">Ví dụ:</p>
                        <p class="des">
                            Giả sử cho cây, bao gồm các nút a, b, c, d, e, k, g, h, i, l như hình
                            như sau :
                        </p>
                        <img style="width: 100%;" src="./img/monhoc/pic9.jpg" alt="">
                        <p class="des">
                            Thứ tự duyệt cây theo thứ tự trước, giữa và sau sẽ được kết quả
                            như sau:
                        </p>

                    </div>
                    <div class="tab-pane" id="CHƯƠNG_6">
                        <h1 class="heading1">CHƯƠNG 6: BẢNG BĂM</h1>
                        <h2 class="heading2" id="6.1">6.1. BẢNG BĂM</h2>
                        <h3 class="heading3" id="6.1.1">6.1.1. Định nghĩa </h3>
                        <p class="des">Bảng băm (hash table) là phương pháp tham chiếu trực tiếp một phần tử trong trong bảng lưu dữ liệu thông qua việc biến đ i số học trên khóa của phần tử để có được địa chỉ tương ứng của phần tử đang xét ở trong bảng.</p>
                        <p class="des">
                            Như thế, giả sử các khóa là những số nguyên từ 1 đến N thì có thể
                            lưu phần tử thứ i ở vị trí thứ i của bảng và có thể truy xuất trực tiếp
                            các phần tử này bằng giá trị khóa của phần tử. Điều đó cho thấy bảng
                            b m là một trong những phương pháp tìm kiếm hữu hiệu.
                        </p>
                        <p class="des">
                            Về mặt toán học, bảng b m là một ánh xạ H từ tập các khóa K
                            vào tập các địa chỉ A: H: K → A
                        </p>
                        <p class="des">
                            Trong bảng b m, thông thường tập các khóa lớn hơn rất nhiều so
                            với tập các địa chỉ bộ nhớ (chỉ số của bảng). Do đó, hàm H là một
                            hàm ánh xạ nhiều – một.
                        </p>
                        <p class="des">
                            Bảng b m có thể x m như ự mở rộng của mảng thông thường.
                            Việc địa chỉ hóa trực tiếp trong mảng cho phép truy nhập đến phần tử
                            bất kỳ trong thời gian O(1). Mặc dù, trong tình huống xấu nhất thao
                            tác tìm kiếm đòi hỏi thời gian O(N) giống như trên danh sách liên kết,
                            nhưng trên thực tế bảng b m làm việc hiệu quả hơn nhiều.
                        </p>
                        <h3 class="heading3" id="6.1.2">6.1.2. Quy trình thực hiện lưu trữ trong bảng băm</h3>
                        <p class="des">Quy trình thực hiện lưu trữ trong bảng b m bao gồm các bước sau:</p>
                        <ul>
                            <li class="list">Bước đầu tiên là xác định hàm H để biến đ i khóa cần tìm thành địa chỉ trong bảng. Trường hợp lý tưởng nhất là những khóa khác nhau thông qua hàm H sẽ cho ra những địa chỉ khác nhau. Tuy nhiên, trong thực tế thì hai hoặc nhiều khóa khác nhau thông qua hàm H sẽ có thể cho ra cùng một địa chỉ trong bảng.</li>
                            <li class="list">
                                Bước tiếp theo là quá trình giải quyết xung đột (collision) cho
                                trường hợp những khóa khác nhau có cùng một địa chỉ trong bảng.
                                Một trong những phương pháp giải quyết đụng độ ph biến là dùng
                                danh sách liên kết, do sẽ tạo ra sự linh hoạt trong việc kết hợp các
                                khóa có cùng địa chỉ khi kết hợp danh sách liên kết.
                            </li>
                        </ul>
                        <h3 class="heading3" id="6.1.3">6.1.3. Các thao tác trên bảng băm</h3>
                        <p class="des">
                            Các thao tác chính trên bảng b m được xây dựng nhằm h trợ
                            cho thực hiện các thao tác trên dữ liệu được lưu trữ trong bảng b m.
                        </p>
                        <ul>
                            <li class="list">Thao tác khởi tạo: thao tác này khởi tạo bảng b m, cấp phát vùng nhớ hay quy định số phần tử (kích thước) của bảng b m</li>
                            <li class="list">Thao tác kiểm tra r ng: mục đích kiểm tra bảng b m có r ng  hay không ?</li>
                            <li class="list">Thao tác lấy kích thước của bảng b m cho biết số phần tử hiện có trong bảng b m.</li>
                            <li class="list">Thao tác tìm kiếm : tìm kiếm một phần tử trong bảng b m th o khoá k được chỉ định trước đó.</li>
                            <li class="list">Thao tác thêm mới phần tử : thêm một phần tử vào bảng b m. Sau khi thêm số phần tử hiện có của bảng b m t ng thêm một đơn vị</li>
                            <li class="list">Thao tác loại bỏ phần tử : loại bỏ một phần tử ra khỏi bảng b m và số phần tử sẽ giảm đi một đơn vị.</li>
                            <li class="list">Thao tác sao chép: mục đích tạo một bảng b m mới từ một bảng b m cũ đã có trước đó.</li>
                            <li class="list">Thao tác duyệt bảng b m: duyệt bảng b m th o thứ tự địa chỉ từ nhỏ đến lớn.</li>
                        </ul>
                        <p class="des">
                            Xét về tính hiệu quả, bảng b m là một phương pháp hiệu quả về
                            thời gian và vùng nhớ. Việc tìm kiếm một khóa bất kỳ với một lần
                            truy xuất vùng nhớ bằng cách cho khóa đó địa chỉ của vùng nhớ khi
                            không bị giới hạn về vùng nhớ. Cũng tương tự như thế, nếu không bị
                            giới hạn về thời gian tìm kiếm thì có thể sử dụng một vùng nhớ có
                            kích thước tối thiểu với phương pháp tìm kiếm tuyến tính.
                        </p>
                        <h2 class="heading2" id="6.2">6.2 HÀM BĂM</h2>
                        <p class="des">
                            Bước đầu tiên trong sử dụng cấu trúc bảng b m là chọn hàm biến
                            đ i khóa để biến đ i các khóa thành các địa chỉ trong bảng. Hàm ánh
                            xạ này gọi là hàm b m (hash function).
                        </p>
                        <p class="des">Về mặt t ng quát, một hàm b m tốt là hàm có khả n ng ph n bố đều trên miền giá trị của địa chỉ.</p>
                        <p class="des">
                            Giả sử gọi N là các phần tử được chứa trong bộ nhớ (thường N là
                            số nguyên tố), hàm b m ẽ biến đ i các khóa (thường là các số
                            nguyên hoặc là các chu i ký tự ngắn) thành số nguyên trong đoạn
                            [0..N – 1].
                        </p>
                        <p class="des">Giả sử các khóa là những số nguyên, hàm b m H(k) là:</p>
                        <pre>H(k) = k mod N</pre>
                        <p class="des">với k là khóa và H(k) là hàm lấy số dư của k chia cho N</p>
                        <h2 class="heading2" id="6.3">6.3. CÁC PHƯƠNG PHÁP GIẢI QUYẾT ĐỤNG ĐỘ</h2>
                        <h3 class="heading3" id="6.3.1">6.3.1. Ph ơng ph p nối kết</h3>
                        <h4 class="heading4" id="6.3.1.1">6.3.1.1. Phương pháp nối kết trực tiếp</h4>
                        <p class="des-italic">Ý tưởng phương pháp</p>
                        <p class="des">
                            Có một câu hỏi đặt ra, đó là trong trường hợp các khóa khác nhau
                            có cùng một địa chỉ trong bảng thì phải lưu trữ như thế nào trong
                            bảng?. Một cách đơn giản là ứng với m i địa chỉ sẽ có một danh sách
                            liên kết chứa các phần tử có khóa khác nhau có cùng một địa chỉ. Như
                            vậy, phải sử dụng một danh sách gồm N phần tử chứa địa chỉ đầu của
                            danh sách liên kết. Đó là cách thực hiện của phương pháp nối kết trực
                            tiếp <em>(direct chaining)</em>.
                        </p>
                        <img src="./img/hinh6-1.jpg" class="img">
                        <p class="des-italic">Cài đặt bảng băm dùng phương pháp nối kết trực tiếp </p>
                        <ul>
                            <li class="letter-list" style="margin-left: 10px;"><strong>Khai báo cấu trúc bảng băm</strong></li>
                            <pre>#define M 100 // giả sử dùng bảng băm gồm 100 phần tử
    typedef struct tagNODE {
            int key;
                tagNODE *next
    }NODE, *NODEPTR;</pre>
                            <li class="letter-list" style="margin-left: 10px;"><strong>Khai báo mảng bucket chứa M phần tử</strong></li>
                            <pre>NODEPTR bucket[M];</pre>
                            <li class="letter-list" style="margin-left: 10px;"><strong>Xây dựng hàm băm</strong></li>
                            <p class="des">Giả sử chọn hàm băm f(key)=key % M</p>
                            <pre> int hash(int key) {
        return key % M;
    }</pre>
                            <li class="letter-list" style="margin-left: 10px;"><strong>Xây dựng hàm các thao tác trên bảng băm</strong></li>
                            <ul>
                                <li class="list"><em>Hàm khởi tạo bảng băm</em></li>
                                <pre>void initbucket() {
        int b;
        for (b=0; b< M; b++)
            bucket[b]=NULL;
    }</pre>
                                <li class="list"><em>Hàm kiểm ra b cke b có bị rỗng không? </em></li>
                                <pre>int isempty(int b) {
        return (bucket[b] ==NULL ?TRUE :FALSE);
    }</pre>
                                <li class="list"><em>Hàm kiểm ra bảng băm có rỗng không?</em></li>
                                <pre>int isemptybucket() {
        int b;
        for (b=0; b< M; b++)
            if (!isempty(b))
                return FALSE;
        return TRUE;
    }</pre>
                                <li class="list"><em>Hàm thêm hần ử có khóa k vào bảng băm</em></li>
                                <p class="des">
                                    Giả ử các phần tử trên các buck t là có thứ tự, để thêm một phần
                                    tử khóa k vào bảng b m trước tiên chúng ta xác định buck t ph hợp,
                                    sau đó d ng hàm plac của danh ách liên kết để đặt phần tử vào vi trí
                                    ph hợp trên buck t.
                                </p>
                                <pre>void insert(int k) {
        int b;
        b = hash(k);
        place(b, k);
    }</pre>
                                <li class="list"><em>Hàm xóa hần ử có khóa k rong bảng băm</em></li>
                                <p class="des">Giả ử các phần tử trên các buck t là có thứ tự, để xóa một phần tử khóa k trong bảng b m cần thực hiện </p>
                                <ul>
                                    <li class="square-list">Xác định bucket ph hợp</li>
                                    <li class="square-list">
                                        Tìm phần tử để xóa trong buck t đã được xác định, nếu tìm
                                        thấy phần tử cần xóa thì loại bỏ phần tử th o các ph p toán
                                        tương tự loại bỏ một phần tử trong danh ách liên kết
                                    </li>
                                </ul>
                                <pre>void remove(int k) {
        int b;
        NODEPTR p, q;
        b = hash(k);
        p = bucket[b];
        q = p;
        while (p != NULL && p->key != k) {
            q = p;
            p = p->next;
        }
        if (p == NULL)
            printf("\n không có nút có khóa %d" ,k);
        else {
            if (p == bucket[b])
            pop(b); // tác vụ pop
            else
            delafter(q); // tác vụ xóa phần tử q trong danh sách liên kết
        }
    }</pre>
                                <li class="list"><em>Hàm tìm kiếm</em></li>
                                <p class="des">Tìm kiếm một phần tử trong bảng b m, nếu không tìm thấy hàm trả về giá trị NULL,nếu tìm thấy hàm trả về địa chỉ phần tử tìm thấy.</p>
                                <pre>NODEPTR search(int k) {
        int b;
        NODEPTR p;
        b = hash(k);
        p = bucket[b];
        while (p != NULL && p->key != k)
            p = p->next;
        if (p == NULL | | k !=p->key) // không tìm hấy phần tử
            return NULL;
        else
            return p;
    }</pre>
                                <p class="des">Nhận xét:</p>
                                <p class="des">Bảng b m d ng phương pháp nối kết trực tiếp ẽ "b m N phần tử vào bảng gồm M phần tử.</p>
                                <p class="des">
                                    Để tốc độ thực hiện các ph p toán trên bảng hiệu quả, cần chọn
                                    hàm b m ao cho b m đều N phần tử của bảng b m cho M phần tử,
                                    lúc này trung bình m i buck t ẽ có N / M phần tử.
                                </p>
                                <p class="des">
                                    Nếu chọn M càng lớn thì tốc độ thực hiện các ph p toán trên bảng
                                    b m càng nhanh. Tuy nhiên ẽ dùng nhiều bộ nhớ. Do vậy, cần điều
                                    chỉnh M để dung hòa giữa tốc độ truy xuất và dung lượng bộ nhớ cần
                                    sử dụng.
                                </p>
                                <p class="des">
                                    Nếu chọn M = N thì n ng xuất tương đương với truy xuất trên
                                    mảng (có bậc O(1)), tuy nhiên tốn nhiều bộ nhớ.
                                </p>
                                <p class="des">Nếu chọn M = N / k (với k =2,3,4,…) thì ít tốn bộ nhớ hơn k lần, nhưng tốc độ lại chậm đi k lần. </p>
                            </ul>
                        </ul>
                        <h4 class="heading4" id="6.3.1.2">6.3.1.2. Phương pháp nối kết hợp nhất </h4>
                        <p class="des-italic">Ý tưởng giải thuật</p>
                        <p class="des">
                            T chức bảng b m của phương pháp nối kết hợp nhất (coalesced
                            chaining) là phương pháp nối kết mà m i phần tử có một vùng chứa
                            chỉ số của phần tử kế tiếp, khi có sự đụng độ xảy ra
                        </p>
                        <p class="des">Giả sử các khóa có giá trị hàm b m và thứ tự thêm vào như sau </p>
                        <ul>
                            <li>Khóa: A B C D</li>
                            <li>Hash: 1 2 1 1</li>
                        </ul>
                        <p class="des"> hi đó, khi thêm khóa vào bảng b m, vị trí H(A) = 1 là vị trí trống nên khóa được thêm vào ngay vị trí 1. </p>
                        <p class="des">
                            Khi thêm khóa C vào bảng b m, vị trí H (C) = 1 đang chứa
                            khóa A nên xảy ra đụng độ, do đó phải tìm kiếm vị trí trống đầu
                            tiên từ phía dưới lên. Vị trí trống đầu tiên là N, ta thêm khóa C vào
                            vị trí N.
                        </p>
                        <p class="des">
                            Khi thêm vào khóa D, vì vị trí H (D) = 1 đã chứa khóa , ta đi
                            theo con trỏ Next của vị trí này để đến vị trí M, nhưng vị trí M đã
                            chứa khóa C và con trỏ Next của vị trí này bằng 0 nên ta thêm khóa
                            D vào vị trí M – 1 (vị trí trống đầu tiên từ phía dưới bảng trở lên).
                        </p>
                        <img src="./img/monhoc/hinh6-2.jpg">
                        <p class="des-italic">Cài đặt bảng băm dùng phương pháp nối kết hợp nhất </p>
                        <ul>
                            <li class="letter-list"><strong>Khai báo cấu trúc bảng băm</strong></li>
                            <pre>#define M 100 // giả sử dùng bảng băm gồm 100 phần tử
    #define NULLKEY -1
    struct node {
        int key; // khóa của nút trên bảng băm
        int Next; // con trỏ trỏ đến nút tiếp theo
    };
    </pre>
                            <li class="letter-list"><strong>Khai báo bảng băm</strong></li>
                            <pre>struct node bucket[M];
    int avail; // vị trí trống đầu tiên trên bảng băm</pre>
                            <li class="letter-list"><strong>Xây dựng hàm băm</strong></li>
                            <p class="des">Giả sử chúng ta chọn hàm băm dạng modulo f(key)=key % 10</p>
                            <pre>int hash(int key) {
        return key % 10;
    }</pre>
                            <li class="letter-list"><strong>Xây dựng hàm các thao tác trên bảng băm</strong></li>
                            <ul>
                                <li class="list"><em>Hàm khởi tạo bảng băm</em></li>
                                <p class="des">
                                    Hàm này khởi tạo bảng b m bằng cách gán tất cả các phần tử trên
                                    bảng có trường key là Null, con trỏ N xt có giá trị là –1 cho tất cả các
                                    phần tử trên bảng b m.
                                </p>
                                <p class="des">Gán biến toàn cục avail=M-1 là phần tử cuối danh ách chu n bị cấp phát nếu xảy ra xung đột.</p>
                                <pre>void initbucket() {
        for (int i=0; i< M ; i++) {
            bucket[i].key = NULLKEY;
            bucket[i].key = -1;
        }
        avail = M-1;
    }</pre>
                                <li class="list"><em>Hàm kiểm tra bảng băm có rỗng không?</em></li>
                                <pre>int isemptybucket() {
        for (int i=0; i< M; i++)
            if (bucket[i].key != NULLKEY)
                return FALSE;
        return TRUE;
    }</pre>
                                <li class="list"><em>Hàm tìm kiếm trong bảng băm</em></li>
                                <p class="des">
                                    Hàm tìm kiếm th o phương pháp tuyến tính, nếu không tìm thấy
                                    hàm tìm kiếm trả về trị M, nếu tìm thấy hàm này trả về địa chỉ tìm
                                    thấy.
                                </p>
                                <pre>void search(int k) {
        int i;
        i = hash(k);
        while (k !=hashtable[i].key && i !=-1)
            i = hashtable[i].Next;
        if (k== hashtable[i]key)
            return i; // tìm thấy phần tử
        return M;
    }</pre>
                                <li class="list"><em>Hàm lấy phần tử trống trong bảng băm</em></li>
                                <p class="des">Hàm này chọn phần tử còn trống phía cuối bảng b m để cấp phát khi xảy ra xung đột. </p>
                                <pre>int getempty()
    {
        while (hashtable[avail].key !=NULLKEY)
            avail - -;
        return avail;
    }</pre>
                                <li class="list"><em>Hàm thêm phần tử vào bảng băm</em></li>
                                <p class="des">Hàm thực hiện thêm phần tử có khóa k vào bảng b m</p>
                                <pre>void insert(int k) { 
        int i, j;
        i = search(k);
        if (i != M) {
            printf("\n Khóa %d đã tồn tại", k);
            return;
        }
        i = hash(k);
        while (hashtable[i].Next >= 0)
            i = hashtable[i].Next;
        if (hashtable[i].key == NULLKEY) {
            j = i;
        } else {
            j = getempty();
            if (j < 0) {
                printf("\n Bảng băm đầy");
                return;
            }
            hashtable[i].Next = j;
        }
        hashtable[j].key = k;
        return j;
    }</pre>
                            </ul>
                        </ul>
                        <p class="des">Nhận xét:</p>
                        <p class="des">
                            Thực chất cấu trúc bảng b m này chỉ tối ưu khi b m đều, nghĩa là
                            m i danh ách liên kết chứa một vài phần tử bị xung đột, tốc độ truy
                            xuất lúc này lả O(1). Trường hợp xấu nhất là b m không đều, vì hình
                            thành một danh ách có N phần tử nên tốc độ truy xuất lúc này là
                            O(N)
                        </p>
                        <h3 class="heading3" id="6.3.2">6.3.2. Phương pháp địa chỉ mở</h3>
                        <p class="des-italic">Phương pháp giải thuật</p>
                        <p class="des">
                            Phương pháp nối kết trực tiếp có một nhược điểm là phải duy trì
                            các danh sách liên kết và m i phần tử phải có thêm vùng liên kết địa
                            chỉ đến phần tử kế tiếp trong danh sách. Có một cách khác để giải
                            quyết đụng độ là khi có đụng độ xảy ra thì ta sẽ tìm đến vị trí kế tiếp
                            nào đó ở trong bảng cho đến khi nào tìm thấy phần tử mong muốn
                            hoặc vị trí kế tiếp là vị trí trống.
                        </p>
                        <p class="des">
                            Trong phương pháp địa chỉ mở (open addressing), tất cả các
                            phần tử đều được cất giữ vào bảng. Do đó m i ô của bảng hoặc là
                            chứa khóa hoặc là NULL. tưởng của phương pháp này như au
                        </p>
                        <ul>
                            <li class="square-list">
                                Để thực hiện thêm phần tử, nếu ô địa chỉ sau khi thực hiện
                                hàm b m bị chiếm giữ, ta sẽ tiến hành dò thử các ô còn lại của
                                bảng cho đến khi tìm được ô r ng để nạp phần tử vào. Thay vì
                                tìm tuần tự theo thứ tự 0, 1, …, N – 1 (thời gian Θ (N)), dãy
                                các vị trí sẽ phụ thuộc vào giá trị khóa của phần tử được b
                                ung. Để xác định các ô dò thử, ta sẽ mở rộng định nghĩa hàm
                                b m.
                            </li>
                            <li class="square-list">Khi tìm kiếm trên bảng b m, ta sẽ thực hiện giống như cách dò thử như khi thực hiện chèn phần tử vào bảng.</li>
                            <ul>
                                <li class="list" style="margin-left: 100px">Nếu con trỏ trả về là NULL thì phần tử cần tìm không có trong bảng. </li>
                                <li class="list" style="margin-left: 100px">Ngược lại là đã có phần tử trong bảng. </li>
                            </ul>
                            <li class="square-list">Mở rộng định nghĩa hàm b m như sau </li>
                            <li>h: U x {0, 1, …, N - 1} → {0, 1, …, N - 1}</li>
                            <li class="square-list">
                                Trong phương pháp địa chỉ mở ta đòi hỏi, với m i khóa k, dãy
                                dò thử < h (k, 0), h (k, 1), …, h (k, N – 1)> phải là một hoán vị
                                của < 0, 1, …, N – 1>, do đó m i vị trí trong bảng sẽ được xét
                                như là một ô để chứa khóa mới khi ta tiến hành b sung vào bảng.
                            </li>
                        </ul>
                        <p class="des-italic">Cài đặt bảng băm dùng phương pháp địa chỉ mở</p>
                        <ul>
                            <li class="list">Hàm b sung khóa k vào bảng băm được thực hiện qua các bước :</li>
                            <ul>
                                <li class="list"><em>Bước 1: </em>Khởi tạo i = 0</li>
                                <li class="list"><em>Bước 2: </em>Thực hiện lặp cho đến khi i = N</li>
                                <ul>
                                    <li>Gán j = h(k, i)</li>
                                    <li>Nếu (T[j] = NULL)</li>
                                    <li>{</li>
                                    <li>Gán T[j] = k</li>
                                    <li>Trả về j</li>
                                    <li>}</li>
                                    <li>Ngược lại : Gán i = i + 1</li>
                                </ul>
                            </ul>
                            <li class="list">Hàm tìm kiếm khóa k trong bảng băm được thực hiện qua các bước:</li>
                            <ul>
                                <li class="list"><em>Bước 1:</em> Khởi gán i = 0 </li>
                                <li class="list"><em>Bước 2:</em> Thực hiện lặp cho đến khi T[j] = NULL hoặc i = N</li>
                                <ul>
                                    <li>Gán j = h(k, i)</li>
                                    <li>Nếu (T[j] = j)</li>
                                    <li>Trả về j</li>
                                    <li>Gán i = i + 1</li>
                                    <li>Trả về NULL</li>
                                </ul>
                            </ul>
                            <li class="list">Hàm dò thử trong bảng băm</li>
                            <p class="des">Có ba kỹ thuật dò thử thường được sử dụng:</p>
                            <ul>
                                <li class="list-bullet">Dò tuyến tính (Linear Probing)</li>
                                <li class="list-bullet">Dò toàn phương (Quadratic Probing)</li>
                                <li class="list-bullet">Băm kép (Double hashing)</li>
                            </ul>
                            <p class="des">Các kỹ thuật này đều đảm bảo < h (k, 1), h(k, 2), …, h(k, m)> là hoán vị của < 0, 1, …, N – 1> đối với m i khóa k.</p>
                            <h4 class="heading4" id="6.3.2.1">6.3.2.1 Dò tuyến tính </h4>
                            <p class="des-italic">Ý tưởng phương pháp </p>
                            <p class="des">
                                Phương pháp địa chỉ mở đơn giản nhất có thể thực hiện là dò
                                thử tuyến tính. hi đó, một khi có đụng độ xảy ra ta tìm đến vị trí
                                kế tiếp (chỉ số t ng lên 1).
                            </p>
                            <p class="des">Giả sử cho hàm b m h' U → {0, 1, …, N - 1}, phương pháp dò tuyến tính sử dụng hàm b m mở rộng như sau:</p>
                            <li>h(k,i) = (h'(k) + i) mod N , với i = 0, 1, …, N - 1. </li>
                            <p class="des">
                                Như thế giả sử cho khóa k, ô đầu tiên trong bảng b m được dò
                                thử tuyến tính là T[h' (k)]. Sau đó sẽ dò thử ô T[h' (k) + 1], T[h' (k) +
                                2],… cho đến ô T[N - 1].
                            </p>
                            <p class="des-italic">Cài đặt bảng băm dùng phương php dò tuyến tính</p>
                            <ul>
                                <li class="letter-list"><strong>Khai báo cấu trúc bảng băm</strong></li>
                                <pre>#define NULLKEY –1
    #define M 100 // giả sử dùng bảng băm gồm 100 hần ử
    struct node
    {
        int key;
    };</pre>
                                <li class="letter-list"><strong>Khai báo bảng băm</strong></li>
                                <pre>struct node hashtable[M]; // khai báo bảng băm có M hần ử
    int NODEPTR; // biến toàn cục chỉ số nút hiện có trên bảng băm</pre>
                                <li class="letter-list"><strong>Xây dựng hàm băm</strong></li>
                                <p class="des">Giả sử chúng ta chọn hàm b m: f(key)=key %10</p>
                                <pre>int hash(int key) {
        return key % 10;
    }
                                    </pre>
                                <li class="letter-list"><strong>Xây dựng hàm các thao tác trên bảng băm</strong></li>
                                <ul>
                                    <li class="list"><em>Hàm khởi tạo bảng băm</em></li>
                                    <p class="des">Gán tất cả các phần tử trên bảng có trường key là NULL. Gán biến toàn cục N=0.</p>
                                    <pre>void initialize( )
    {
        int i;
        for (i=0;i< M;i++)
            hashtable[i].key=NULLKEY;
        N=0;
    }
    </pre>
                                    <li class="list"><em>Hàm kiểm tra bảng băm có rỗng không?</em></li>
                                    <pre>int isemptybucket() {
        return (N==0 ? TRUE : FALSE);
    }</pre>
                                    <li class="list"><em>Hàm kiểm ra bảng băm có đầy không ?</em></li>
                                    <pre>int full( )
    {
        return (N==M-1 ? TRUE : FALSE);
    }
    </pre>
                                    <li class="list"><em>Hàm tìm kiếm </em></li>
                                    <pre>int search(int k)  {
        int i;
        i=hashfunc(k);
        while (hashtable[i].key!=k && hashtable[i].key !=NULKEY)
            { i=i+1;
            if (i>=M)
                i=i-M;
            }
        if (hashtable[i].key==k)
            return i;
        else
            return M;
    }
    </pre>
                                    <li class="list"><em>Hàm thêm phần tử vào bảng băm</em></li>
                                    <pre>int insert(int k) {
        int i, j;
        if (full( ))
            { printf ("Bảng b m đầy, không thể thêm nút có khóa %d ",k);
            return;
            }
        i=hashfunc(k);
        while (hashtable[i].key !=NULLKEY) 
            { i ++;
            if (i >M)
                i= i-M;
            }
        hashtable[i].key=k;
        N=N+1;
        return i;
    }</pre>
                                </ul>
                            </ul>
                            <h4 class="heading4" id="6.3.2.2">6.3.2.2. Dò toàn phương </h4>
                            <p class="des-italic">Ý tưởng phương pháp</p>
                            <p class="des">
                                Trong phương pháp dò thử tuyến tính ở trên, ta thấy rằng để tìm
                                kiếm một phần tử có khóa k1 thì bắt đầu tìm kiếm từ vị trí h(k1) của
                                bảng b m. Nếu phần tử ở vị trí này không phải là phần tử cần tìm thì
                                ta tìm đến vị trí kế tiếp và cứ như thế cho đến khi nào tìm thấy phần tử
                                này hoặc cho đến khi gặp vị trí trống p nào đó.
                            </p>
                            <p class="des">
                                Trong trường hợp không tìm thấy và cần thêm phần tử mới vào
                                bảng b m thì ta lưu phần tử mới tại vị trí p. Nhưng au đó, ta không
                                thể thêm một phần tử có khóa là k2 tại vị trí p nữa, mặc d hàm b m
                                h(k2) có giá trị là p và ta phải tìm đến vị trí trống kế tiếp để thêm phần
                                tử khóa k2 vào trong bảng b m. Như vậy, thời gian tìm kiếm một vị trí
                                trống kế tiếp sẽ rất lâu khi bảng gần đầy.
                            </p>
                            <p class="des">Sử dụng hàm b m mở rộng như sau:</p>
                            <li>h(k, i) = (h'(k) + i^2) mod N, với i = 0, 1, …, N - 1.</li>
                            <p class="des">trong đó H’ là hàm b m ban đầu,</p>
                            <li>c1 và c2 ≠ 0 là các hằng số, i = 0, 1, …, N – 1.</li>

                            <p class="des-italic">Cài đặt bảng băm dùng phương pháp dò toàn phương</p>
                            <ul>
                                <li class="letter-list"><strong>Khai báo cấu trúc bảng băm</strong></li>
                                <pre>#define NULLKEY –1
    #define M 100 // giả sử dùng bảng băm gồm 100 hần ử
    struct node
    {
        int key;
    };</pre>
                                <li class="letter-list"><strong>Khai báo bảng băm</strong></li>
                                <pre>struct node hashtable[M]; //khai báo bảng băm có M hần ử
    int NODEPTR; // biến oàn cục chỉ số nú hiện có rên bảng băm</pre>
                                <li class="letter-list"><strong>Xây dựng hàm băm</strong></li>
                                <p class="des">Giả ử chúng ta chọn hàm b m: f(key)=key %10.</p>
                                <pre>int hashfunc(int key)
    {
        return(key% 10);
    }
    </pre>
                                <li class="letter-list"><strong>Xây dựng hàm các thao tác trên bảng băm</strong></li>
                                <ul>
                                    <li class="list"><em>Hàm khởi tạo bảng băm </em></li>
                                    <p class="des"> Gán tất cả các phần tử trên bảng có trường key là NULL.</p>
                                    <p class="des"> Gán biến toàn cục N=0</p>
                                    <pre>void initialize( )
     {
        int i;
        for (i=0;i< M;i++)
            hashtable[i].key=NULLKEY;
        N=0;
    }</pre>
                                    <li class="list"><em>Hàm kiểm tra bảng băm có trống không ?</em></li>
                                    <pre>int empty( )
    {
        return(N==0 ? TRUE : FALSE);
    }</pre>
                                    <li class="list"><em>Hàm kiểm tra bảng băm có đầy không ?</em></li>
                                    <pre>int full( )
     {
        return (N==M-1 ? TRUE : FALSE);
     }</pre>
                                    <li class="list"><em>Hàm tìm kiếm</em></li>
                                    <pre>int search(int k)
     {
        int i, d;
        i = hashfuns(k);
        d = 1;
        while (hashtable[i].key!=k &&hashtable[i].key !=NULLKEY)
            { i = (i+d) % M; //băm lại
            d = d+2;
            }
        hashtable[i].key =k;
        N = N+1;
        return i;
    }</pre>
                                </ul>
                            </ul>
                            <h4 class="heading4" id="6.3.2.3">6.3.2.3. Hàm băm kép</h4>
                            <p class="des-italic">Ý tưởng phương pháp</p>
                            <p class="des">
                                Băm kép (double hashing) là phương pháp tốt nhất có thể sử dụng
                                trong phương pháp địa chỉ mở ,vì dãy dò thử tạo được bởi phương
                                pháp này có tính chất giống như một hoán vị ngẫu nhiên.
                            </p>
                            <p class="des">Trong phương pháp hàm băm kép, ta sử dụng hàm băm mở rộng:</p>
                            <li>h(k, i) = (h1(k) + ih2(k)) mod N,</li>
                            <p class="des">trong đó h1, h2 là các hàm băm bổ trợ.</p>
                            <p class="des-italic">Cài đặt bảng băm dùng phương pháp băm kép </p>
                            <ul>
                                <li class="letter-list"><strong>Khai báo cấu trúc bảng băm</strong></li>
                                <pre>#define NULLKEY –1
    #define M 100 // giả sử dùng bảng băm gồm 100 hần ử
    struct node
    {
        int key;
    };
    </pre>
                                <li class="letter-list"><strong>Khai báo bảng băm</strong></li>
                                <pre>struct node hashtable[M]; //khai báo bảng băm có M hần ử
    int NODEPTR; // biến toàn cục chỉ số nút hiện có trên bảng băm</pre>
                                <li class="letter-list"><strong>Xây dựng hàm băm</strong></li>
                                <p class="des">Giả sử ta chọn hai 2 hàm băm :</p>
                                <li>f1(key)=key % M </li>
                                <li>f2(key) = M - 2 - key % (M-2)</li>
                                <pre>int hashfunc(int key)
     {
        return(key%M);
     }
    int hashfunc2(int key)
     {
        return(M-2 -key%(M-2));
     }
    </pre>
                                <li class="letter-list"><strong>Xây dựng hàm các thao tác trên bảng băm</strong></li>
                                <ul>
                                    <li class="list"><em>Hàm khởi tạo bảng băm</em></li>
                                    <p class="des">Gán tất cả các phần tử trên bảng có trường k y là NULL. </p>
                                    <p class="des">Gán biến toàn cục N = 0</p>
                                    <pre>void initialize( )
    {
        int i;
        for (i=0;i< M;i++)
            hashtable[i].key=NULLKEY;
        N=0;
    }
    </pre>
                                    <li class="list"><em>Hàm kiểm ra bảng băm có rống không ?</em></li>
                                    <pre>int empty( )
     {
        return(N==0 ? TRUE : FALSE);
     }</pre>
                                    <li class="list"><em>Hàm kiểm ra bảng băm có đầy không ?</em></li>
                                    <pre>int full( )
     {
        return (N==M-1 ? TRUE : FALSE);
     }
    </pre>
                                    <li class="list"><em>Hàm tìm kiếm</em></li>
                                    <pre>int search(int k)
     {
        int i, j ;
        i = hashfunc (k);
        j = hashfunc2 (k);
        while (hashtable[i].key!=k && hashtable[i].key ! = NULLKEY)
            i = (i+j) % M ; //băm lại
        if (hashtable ([i]).key == k) // ìm hấy k
            return i ;
        else // không ìm hấy k
            return M ;
    }</pre>
                                    <li class="list"><em>Hàm thêm phần tử có khoá k vào bảng băm</em></li>
                                    <pre>int insert(int k)
    {   
        int i, j;
        if (full()) 
            { printf "Bảng b m đầy") ;
            return M ;
        }
        if (search (k) < M)
            { printf ("Đã có khóa này trong bảng b m") ;
            return M;
        }
        i = hashfunc(k); // hàm băm 1
        j = hashfunc2 (k); // hàm băm 2
        while (hashtable [i].key ! = NULLEY)
            i = (i + j) % M; // băm lại
        hashtable [i].key = k ;
        N = N+1;
        return i ;
    }
    </pre>
                                </ul>
                            </ul>
                            <p>Nhận xét:</p>
                            <p class="des">Nên chọn ố địa chỉ M là ố nguyên tố. Bảng b m đầy khi N = M-1, ta nên dành ít nhất một phần tử trống trên bảng b m.</p>
                            <p class="des">
                                Bảng b m được cài đặt th o cấu trúc này linh hoạt hơn bảng b m
                                d ng phương pháp dò tuyến tính và phương pháp dò bậc hai, do d ng
                                hai hàm b m khác nhau nên việc rải phần tử mang tính ngẫu nhiên
                                hơn, nếu bảng b m chưa đầy tốc độ truy xuất có bậc O(1).
                            </p>
                            <p class="des">Trường hợp xấu nhất là bảng b m gần đầy, tốc độ truy xuất chậm do thực hiện nhiều lần so sánh.</p>
                            <h3 class="heading3" id="6.3.3">6.3.3. Ph ơng ph p nhân</h3>
                            <p class="des-italic">Ý tưởng phương pháp</p>
                            <p class="des">Phương pháp nhân (multiplication method) để xây dựng hàm b m được tiến hành th o hai bước. </p>
                            <ul>
                                <li class="list">Đầu tiên ta nhân k với một hằng số A, 0 < A < 1 và lấy phần thập phân của kA. </li>
                                <li class="list">Sau đó nh n giá trị này với m rồi lấy phần nguyên của kết quả.</li>
                            </ul>
                            <p class="des-italic">Cài đặt</p>
                            <ul>
                                <li class="list">Chọn hằng số A, 0 < A < 1</li>
                                <li class="list">Hàm h(k) = M(kA - |kA|)</li>
                                <li class="list">Nên chọn giá trị M = 2<sup>p</sup></li>
                                <li class="list">Nên chọn giá trị A không quá gần với 0 hoặc 1.</li>
                            </ul>
                            <h2 class="heading2" id="6.4">6.4. HẠN CHẾ CỦA BẢNG BĂM</h2>
                            <p class="des">
                                Bên cạnh các ưu điểm của bảng b m đã được trình bày trong
                                các phần trên, bảng b m có 2 hạn chế cần quan tâm trong quá trình sử
                                dụng bảng b m
                            </p>
                            <p class="des">Việc quan t m đến các hạn chế này giúp cho việc sử dụng bảng b m trở nên hiệu quả hơn.</p>
                            <p class="des-italic">Vấn đề kích thước bảng băm</p>
                            <p class="des">
                                Nhận thấy rằng, kích thước bảng b m thường là cố định và
                                không thể điều chỉnh theo yêu cầu thực tế trong khi đang ử dụng. Do
                                đó, bằng cách nào đó, trước khi sử dụng ta cần phải ước lượng trước
                                số phần tử cần được sử dụng để tránh sử dụng lãng phí vùng nhớ. Tuy
                                nhiên, ngay cả trong trường hợp số phần tử cần lưu trữ là được biết
                                trước thì để có được hiệu quả cao thì kích thước của bảng b m đôi khi
                                cũng thường phải lớn.
                            </p>
                            <p class="des-italic">Vấn đề thực hiện thao tác trong bảng băm</p>
                            <p class="des">
                                Việc thực hiện các thao tác trên bảng b m, ví như thao tác loại
                                bỏ hoặc thao tác thêm một phần tử trên bảng b m đôi khi lại trở nên
                                phức tạp với một số phương pháp đã trình bày ở trên, do bản chất của
                                vấn đề nằm ở ch là thao tác có dễ dàng hoặc thuận lợi hay không là
                                nằm ở cách thức ta t chức cấu trúc lưu trữ bảng b m khi tiến hành sử
                                dụng.
                            </p>
                            <p class="des">
                                Do đó, việc xem xét một cách thức t chức dữ liệu nào đó nhằm
                                mang đến sự dễ dàng, thuận lợi hơn là một yếu tố cũng cần xem xét.
                                Cấu trúc cây có thể mang lại hiệu quả hơn và có thể phù hợp hơn
                                trong bối cảnh khối lượng dữ liệu cần lưu trữ trong bảng b m là lớn và
                                ta chưa biết trước được t ng khối lượng dữ liệu cần lưu trữ này.
                            </p>

                            <br>

                            <p><strong>BÀI TẬP CHƯƠNG 6</strong></p>
                            <ul>
                                <li class="number-list">Hãy trình bày ưu điểm và hạn chế của cấu trúc bảng b m và cho ví dụ minh họa cụ thể ? </li>
                                <li class="number-list">
                                    Cho bảng kích thước 11 ô và tập khóa K = {7, 20, 16, 24, 12,
                                    40, 15}, ta cần nạp các giá trị khóa K vào bảng A sử dụng hàm
                                    b m H(k) = k % 11. Hãy vẽ bảng A sau khi tất cả các giá trị khóa
                                    trong tập được lưu trữ trong bảng A, sử dụng k thuật danh
                                    sách liên kết để xử lý xung đột.
                                </li>
                                <li class="number-list">
                                    Cho bảng kích thước 11 ô và tập khóa K = {30, 10, 56, 14, 22,
                                    60, 15}, ta cần nạp các giá trị khóa K vào bảng A sử dụng hàm
                                    b m H (k) = k % 7. Hãy vẽ bảng A sau khi tất cả các giá trị khóa
                                    trong tập được lưu trữ vào bảng A, sử dụng k thuật dò tuyến
                                    tính để xử lý xung đột.
                                </li>
                                <li class="number-list">
                                    Cho bảng kích thước 11 ô và tập khóa K = {23, 12, 65, 27, 8,
                                    50, 58}, ta cần nạp các giá trị khóa K vào bảng A sử dụng hàm
                                    b m H(k) = k % 10. Hãy vẽ bảng A sau khi tất cả các giá trị
                                    khóa trong tập được lưu trữ vào bảng A, sử dụng k thuật dò
                                    toàn phương để xử lý xung đột.
                                </li>
                                <li class="number-list">
                                    Cho bảng kích thước 11 ô và tập khóa K = {7, 20, 16, 24, 12,
                                    40, 15}, ta cần nạp các giá trị khóa K vào bảng A sử dụng hàm
                                    b m H(k) = k % 11. Hãy vẽ bảng A sau khi tất cả các giá trị khóa
                                    trong tập được lưu trữ vào bảng A, sử dụng k thuật b m k p
                                    để xử lý xung đột, với hàm b m k p thứ 2 tự định nghĩa.
                                </li>
                                <li class="number-list">Viết chương trình minh hoạ bảng b m d ng phương pháp nối kết trong các trường hợp sau : </li>
                                <ul>
                                    <li class="letter-list">Dữ liệu lưu trữ là số nguyên (khoá tìm kiếm là số nguyên).</li>
                                    <li class="letter-list">Dữ liệu lưu trữ là thông tin học sinh, bao gồm: họ tên học sinh, lớp, tên trường (khoá tìm kiếm là tên lớp).</li>
                                </ul>
                                <li class="number-list">Viết chương trình minh hoạ bảng b m d ng phương pháp dò tuyến tính trong các trường hợp sau:  </li>
                                <ul>
                                    <li class="letter-list">Dữ liệu lưu trữ là số nguyên (khoá tìm kiếm là số nguyên).</li>
                                    <li class="letter-list">Dữ liệu lưu trữ là thông tin học sinh, bao gồm: họ tên học sinh, lớp, tên trường (khoá tìm kiếm là tên lớp). </li>
                                </ul>
                                <li class="number-list">Viết chương trình minh hoạ bảng b m d ng phương pháp dò bậc hai trong các trường hợp sau: </li>
                                <ul>
                                    <li class="letter-list">Dữ liệu lưu trữ là số nguyên (khoá tìm kiếm là số nguyên)</li>
                                    <li class="letter-list">Dữ liệu lưu trữ là thông tin học sinh, bao gồm: họ tên học sinh, lớp, tên trường (khoá tìm kiếm là tên lớp).</li>
                                </ul>
                                <li class="number-list">Viết chương trình tạo ra một Từ điển với các thao tác sử dụng bảng b m với các chức n ng như au, biết rằng dữ liệu từ điển lưu trên tập tin : </li>
                                <ul>
                                    <li class="letter-list">Thêm một từ mới: thêm vào từ và nghĩa của từ</li>
                                    <li class="letter-list">Tra từ: nhập vào từ và cho biết nghĩa của từ</li>
                                    <li class="letter-list">Cập nhật từ : thay đ i từ hoặc nghĩa của từ</li>
                                    <li class="letter-list">Xoá từ : xóa từ và và nghĩa của từ</li>
                                </ul>
                                <li class="number-list">Giả sử cho một tập tin lưu thông tin tên người dùng (username) và mật kh u (password) của các người d ng, danh ách người dùng gồm 1000 người. </li>
                                <p class="des">Hãy thực hiện các yêu cầu sau:</p>
                                <ul>
                                    <li class="letter-list">Tạo file chứa 1000 người dùng với thông tin tên người dùng và mật kh u cho từng người.</li>
                                    <li class="letter-list">Viết hàm cho phép nhập vào tên người dùng và mật kh u, dùng bảng b m để kiểm tra tính hợp lệ của tên người dùng và mật kh u.</li>
                                </ul>
                            </ul>

                    </div>
                    <div class="tab-pane" id="CHƯƠNG_7">
                    </div>
                </div>

            </div>
        </div>
    </div>
    <!-- Javascript -->
    <script src="./js/jquery-3.6.0.min.js"></script>
    <script src="./css/bootstrap-3.4.1-dist/js/bootstrap.min.js"></script>
    <script src="https://kit.fontawesome.com/57ae888bd4.js" crossorigin="anonymous"></script>
    <script src="./js/content.js"></script>
    <script src="./js/monhoc.js"></script>

</body>
</html>