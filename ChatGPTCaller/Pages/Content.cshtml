@page
@model ChatGPTCaller.Pages.ContentModel
@{
}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Write Data</title>
    <link rel="stylesheet" href="./css/bootstrap-3.4.1-dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="./css/content.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script src="./css/bootstrap-3.4.1-dist/js/bootstrap.min.js"></script>
    <script src="https://kit.fontawesome.com/57ae888bd4.js" crossorigin="anonymous"></script>
</head>
<body>
    <header class="header">
        <nav class="navbar navbar-inverse">
            <div div class="container-fluid">
                <div class="navbar-header">
                    <a class="navbar-brand" href="./Home">WebSiteName</a>
                </div>
                <ul class="nav navbar-nav">
                    <li class="active"><a href="./Home">Home</a></li>
                    <li><a href="./Content">Content</a></li>
                    <li><a href="./Assistant">Assistant</a></li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href=""><span id="usernameSpan"></span></a></li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle glyphicon glyphicon-user" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"> <span class="caret"></span></a>
                        <ul class="dropdown-menu">
                            <li><a href="./Student_infor">Information</a></li>
                            <li><a href="./Student_Infor">Updating</a></li>
                            <li><a href="#">Something else here</a></li>
                            <li role="separator" class="divider"></li>
                            <li><a href="#">Help</a></li>
                        </ul>
                    </li>
                    <li onclick="logout()"><a href=""><span class="glyphicon glyphicon-log-out" id="logoutButton" onclick="logout()"></span>Logout</a></li>
                </ul>
            </div>
        </nav>
    </header>
    <!-- Phần trên của body -->
    <div class="container-fluid">
        <div class="tieude">
            <div class="row col-sm-12">
                <div class="heading">
                    <h1>Cấu Trúc Dữ Liệu Và Giải Thuật</h1>
                    <p>Thêm bất kỳ nội dung nào bạn muốn giới thiệu ở đây.</p>
                </div>
            </div>
        </div>
    </div>
    <!-- === MAIN === -->
    <div class="container-fluid">
        <div class="row">
            <!-- Đưa phần Table of Contents lên trước -->
            <div class="col-sm-4">

                <div class="sidebar">
                    <h3>Table of Contents</h3>
                    <ul class="nav nav-pills nav-stacked">
                        <li class="active"><a href="#chapter1" data-toggle="tab">CHƯƠNG 1. TỔNG QUAN</a></li>
                        <li><a href="#chapter2" data-toggle="tab">CHƯƠNG 2. SẮP XẾP VÀ TÌM KIẾM</a></li>
                        <li><a href="#chapter3" data-toggle="tab">CHƯƠNG 3. DANH SÁCH LIÊN KẾT</a></li>
                        <li><a href="#chapter4" data-toggle="tab">CHƯƠNG 4. NGĂN XẾP HÀNG ĐỢI</a></li>
                        <li><a href="#chapter5" data-toggle="tab">CHƯƠNG 5. CÂY</a></li>
                        <li><a href="#chapter6" data-toggle="tab">CHƯƠNG 6. BẢNG BĂM</a></li>
                        <li><a href="#chapter7" data-toggle="tab">CHƯƠNG 7. TÀI LIỆU THAM KHẢO</a></li>
                    </ul>

                </div>

            </div>
            <!-- Phần phải -->
            <div class="col-sm-8 tab-content">
                <div class="tab-pane active" id="chapter1">
                    <h2>CHƯƠNG 1. TỔNG QUAN</h2>
                    <p>
                        1. 1. VAI TRÒ CỦA THUẬT TOÁN VÀ CẤU TRÚC DỮ LIỆU
                        Để giải một bài toán trong thực tế bằng chương trình máy tính ta phải bắt đầu từ việc xác định
                        bài toán. Cần nhiều thời gian và công sức để xác định chính xác bài toán cần giải quyết, tức là
                        phải trả lời rõ ràng câu hỏi phải làm gì và như thế nào, vì thông thường hầu hết các bài toán là
                        chưa rõ ràng và có cảm giác phức tạp khi bắt đầu xem xét, tìm hiểu. Để giảm bớt sự phức tạp của
                        các bài toán thực tế, cũng như làm rõ hơn các yêu cầu cần giải quyết, phải hình thức hóa hoặc mô
                        hình hóa bài toán, nghĩa là phát biểu lại bài toán thực tế thành một bài toán hình thức. Khi một
                        bài toán đã được hình thức hoá, ta có thể tìm kiếm cách giải và xác định có hay không một lời
                        giải có sẵn để giải bài toán ấy. Trong trường hợp chưa có lời giải cho bài toán, vẫn có thể dựa
                        vào cách thức ta đã mô hình hóa và các thông tin có liên quan đến bài toán để xây dựng một cách
                        thức giải cho bài toán. Như thế, thông qua thao tác mô hình hóa, sẽ dễ hơn trong việc tìm lời
                        giải cho bài toán ấy – đó chính là giải thuật.
                        Có thể thấy rằng, lời giải là tập hợp các bước hữu hạn nối tiếp nhau để thực hiện các yêu cầu
                        nào đó mà tập hợp của các kết quả thông qua từng bước thực hiện giúp ta giải được bài toán. Có
                        thể thấy rằng các xử lý chi tiết trong từng bước phản ánh các thao tác trên các đối tượng mang
                        thông tin trong bài toán, đó chính là dữ liệu, bao gồm các dữ liệu có sẵn, các dữ liệu nhập vào
                        thêm cho bài toán và các dữ liệu trung gian được tạo ra trong quá trình xử lý. Cách thức dữ liệu
                        lưu trữ và biểu diễn các thông tin cần thiết cho bài toán tạo thành các cấu trúc lưu trữ thông
                        tin – cấu trúc dữ liệu.
                        Như thế khi nói đến lời giải hay nói cách khác là giải thuật thì không thể không nói đến dữ liệu
                        và cách thức xử lý trên dữ liệu ấy. Hơn thế nữa giữa cách thức lưu trữ dữ liệu và giải thuật có
                        mối quan hệ mật thiết với nhau khi giải quyết một bài toán trong tin học.

                        Điều này cũng được Niklaus Wirth - một nhà khoa học uy tín trong lĩnh vực công nghệ thông tin,
                        khẳng định qua một công thức n i tiếng hương trình (Program) = Cấu trúc dữ liệu (Data Structure)
                        + Giải thuật (Algorithm). Điều này nói lên bản chất của việc tìm lời giải cho một bài toán trong
                        tin học là đi tìm một cấu trúc dữ liệu phù hợp để biểu diễn dữ liệu của bài toán và từ đó x y
                        dựng giải thuật phù hợp với cấu trúc dữ liệu đã chọn. Ngày nay, với sự phát triển của các k
                        thuật lập trình, công thức của Wirth không hẳn còn đúng tuyệt đối nữa, nhưng nó vẫn phản ánh sự
                        gắn kết và thể hiện tầm quan trọng của các cấu trúc dữ liệu và giải thuật.

                        1.2. THUẬT TOÁN

                        1.2.1. Định nghĩa thuật t n
                        ó rất nhiều định nghĩa cũng như cách phát biểu khác nhau về định nghĩa của thuật toán. Theo
                        Thomas H . Cormen trong cuốn ách n i tiếng viết về thuật toán ntroduction to lgorithm , thuật
                        toán được định nghĩa là một thủ tục tính toán xác định; nhận vào các giá tri hoặc một tập các
                        giá trị gọi là giá trị đầu vào và inh ra các giá tri hoặc một tập giá trị mới được gọi là giá
                        trị đầu ra. Nói một cách khác, thuật toán giống như là quy trình để hoàn thành một công việc cu
                        thể xác định nào đó.

                        1.1.1 Đ t ng ủa thuật toán
                        Thuật toán có các đặc trưng như sau :
                        - Tính đúng đắn: thuật toán cần phải đảm bảo cho một kết quả đúng au khi thực hiện đối với các
                        bộ dữ liệu đầu vào. Đ y có thể nói là đặc trưng quan trọng nhất đối với một thuật toán.
                        - Tính dừng: thuật toán cần phải đảm bảo ẽ dừng sau một ố hữu hạn bước.
                        - Tính xác định: các bước của thuật toán phải được phát biểu rõ ràng, cụ thể, tránh gây nhầm
                        lẫn.

                        - Tính hiệu quả: thuật toán được x m là hiêụ quả nếu có khả n ng giải quyết hiệu qủa bài toán
                        đặt ra, đáp ứng yêu cầu về mặt thời gian xử lý hoặc không gian lưu trữ trong bộ nhớ.
                        - Tính h á : thuật toán được gọi là có tính phố quát ph biến) nếu có thể giải quyết được một lớp
                        các bài toán tương tự.

                        1.1.2 1.2.3. u ễn thuật t n
                        Có nhiều cách khác nhau để biểu diễn thuật toán, gồm: biểu diễn bằng ngôn ngữ tự nhiên, lưu đồ
                        giải và mã giả.

                        1.2 Biểu diễn bằng ngôn ngữ tự nhiên
                        Ví dụ:
                        Thuật toán tính t ng tất cả các số nguyên dương nhỏ hơn N bằng ngôn ngữ tự nhiên, gồm các bước
                        sau:
                        - Bước 1: Khởi gán giá trị biến S = 0; Khởi gán giá trị biến i = 1;
                        - Bước 2: Nếu i< N thì S=S + i; Ngược lại: Chuyển qua bước 4; - Bước 3: Gán i=i + 1; Quay lại
                        bước 2; - Bước 4: T ng cần tìm là S. Nhận xét: Với cách biểu diễn này, có ưu điểm là đơn
                        giản, dễ hiểu. Tuy nhiên, nhược điểm là hơi dài dòng, đôi lúc khó hiểu, không diễn đạt được
                        rõ ràng một cách trực quan nhất từng bước của thuật toán và mối quan hệ giữa chúng. 1.3 Biểu
                        diễn bằng lưu đồ giải thuật Trong cách biểu diễn này sử dụng, hệ thống các ký hiệu để mô tả
                        chức n ng, ý nghĩa của từng bước thực hiện trong thuật toán. Hệ thống các ký hiệu và chức n
                        ng của các ký hiệu sử dụng để biểu diễn thuật toán : Hình 1.1 Hệ thống các ký hiệu để biểu
                        diễn thuật toán Ví dụ Thuật toán tìm phần tử giá trị lớn nhất trong mảng một chiều a gồm n
                        phần tử được biểu diễn bằng lưu đồ như au Nhận xét: Với cách biểu diễn này, có ưu điểm là t
                        ng tính trực quan, rõ ràng trong các bước thực hiện thuật toán, trong đó có đi u vào từng
                        chi tiết xử lý cụ thể trong từng bước của thuật toán. Tuy nhiên, hạn chế của cách biểu diễn
                        này là cần nhiều thời gian hơn trong việc xây dựng các bước thực hiện so với biểu diễn bằng
                        ngôn ngữ tự nhiên. 1.4 Biểu diễn bằng mã giả Cách biểu diễn này kết hợp giữa sử dụng ngôn
                        ngữ tự nhiên và một ngôn ngữ lập trình nào đó trong biểu diễn các bước thuật toán. Ví dụ:
                        Thuật toán tìm phần tử lớn nhất trong mảng một chiều a gồm n phần tử bằng mã giả được thể
                        hiện như au - Bước 1: Khởi gán giá trị biến a=a ; max 0 - Bước 2: Khởi gán giá trị biến i=1;
                        - Bước 3: while (i<n) { if (a <a ) end while; Nhận xét : max a max i=i +1; } i=a ; i Với
                            cách biểu diễn này, có ưu điểm là đỡ cồng kềnh so với cách biểu diễn bằng lưu đồ giải thuật,
                            rõ ràng hơn o với cách biểu diễn bằng ngôn ngữ tự nhiên. Tuy nhiên, hạn chế của cách biểu
                            diễn này là đòi hỏi phải có kiến thức cơ bản về ngôn ngữ lập trình nào đó để sử dụng biểu
                            diễn các bước thuật toán1. Thông thường hai cách biểu diễn thuật toán sử dụng ph biến là
                            ngôn ngữ tự nhiên và lưu đồ giải thuật. 1.4.1 4 Độ phức tạp thuật toán Định nghĩa về độ phức
                            tạp thuật toán: ho hai hàm f và g có miền xác định trong tập ố tự nhiên. Ta viết f n)=O g
                            n)) và nói f n) có cấp cao nhất là g n) khi tồn tại hằng ố và k ao cho| f n) | ≤ .g n) với
                            mọi n> k
                            Thông thường, để đánh giá mức độ tốt, xấu và so sánh các thuật toán c ng loại, có thể dựa
                            trên hai tiêu chu n:
                             Tiêu chu n thuật toán đơn giản, dễ hiểu, dễ cài đặt.
                             Hoặc tiêu chu n dựa vào thời gian thực hiện và tài nguyên ử dụng để thực hiện trên dữ
                            liệu.
                            Trên thực tế các thuật toán hiệu quả thì thường không dễ hiểu, cách cài đặt hiệu quả cũng
                            không dễ dàng thực hiện và hiểu được một cách nhanh chóng và như thế đôi khi thuật toán càng
                            hiệu quả thì càng khó hiểu, cài đặt càng phức tạp. Tuy nhiên, điều này không phải lúc nào
                            cũng đúng trong mọi trường hợp. Do đó, để đánh giá và o ánh các thuật toán, ta thường dựa
                            trên độ phức tạp về thời gian thực hiện của thuật toán, gọi là độ phức tạp thuật toán.
                            Về bản chất độ phức tạp thuật toán là một hàm ước lượng số phép tính mà thuật toán cần thực
                            hiện, trên một bộ dữ liệu đầu vào kích thước N trong bài toán. hi x m x t o ánh các thuật
                            toán c ng loại, ta thường x t độ phức tạp của thuật toán trong các trường hợp trung bình,
                            xấu nhất và tốt nhất.
                            Phân tích thuật toán là một công việc rất khó kh n, đòi hỏi phải có những hiểu biết sâu sắc
                            về thuật toán và nhiều kiến thức toán học

                            1 Trong những phần sau của cuốn giáo trình này sử dụng ngôn ngữ lập trình C/
                            ++ để biểu diễn các thuật toán

                            khác. Một công việc mà không phải bất cứ người nào cũng làm được, vì phải hiểu được các khái
                            niệm liên quan.
                            Ðánh giá về thời gian của thuật toán không phải là xác định thời gian tuyệt đối chạy thuật
                            toán mất bao nhiêu gi y, bao nhiêu phút,...) để thực hiện thuật toán mà là xác định mối liên
                            quan giữa dữ liệu đầu vào input) của thuật toán và chi phí ố thao tác, ố ph p tính cộng,
                            trừ, nh n, chia, rút c n,...) để thực hiện thuật toán. Sở dĩ người ta không quan t m đến
                            thời gian tuyệt đối của thuật toán, vì yếu tố này phụ thuộc vào tốc độ của máy tính, mà các
                            máy tính khác nhau thì có tốc độ rất khác nhau. Như thế, một cách t ng quát, chi phí thực
                            hiện thuật toán là một hàm ố phụ thuộc vào dữ liệu đầu vào
                            T = f(input)
                            Tuy vậy, khi ph n tích thuật toán, người ta thường chỉ chú ý đến mối liên quan giữa độ lớn
                            của dữ liệu đầu vào và chi phí. Trong các thuật toán, độ lớn của dữ liệu đầu vào thường được
                            thể hiện bằng một con ố nguyên n. hẳng hạn ắp xếp N con ố nguyên, tìm con
                            ố lớn nhất trong N ố, tính điểm trung bình của N học inh, ... Lúc này, người ta thể hiện chi
                            phí thực hiện thuật toán bằng một hàm ố phụ thuộc vào N:
                            T = f(N)
                            Việc x y dựng một hàm T t ng quát như trên trong mọi trường hợp của thuật toán là một việc
                            rất khó kh n, nhiều lúc không thể thực hiện được. hính vì vậy mà ta chỉ x y dựng hàm T cho
                            một ố trường hợp đáng chú ý nhất của thuật toán, thường là trường hợp tốt nhất và xấu nhất.
                            Ta x t lại ví dụ thuật toán tìm phần tử giá trị lớn nhất được nêu ở trên:
                            - Bước 1: Ghi nhớ amax = a1
                            - Bước 2: hởi gán giá trị biến i = 2
                            - Bước 3: Nếu i < N) thì thực hiện : + Bước 3.1: Nếu ai> amax ) thì
                                Ghi nhớ amax = ai
                                + Bước 3.2 : Gán i = i+1 // ăng i lên mộ đơn vị
                                Ngược lại :
                                huyển ang bước 5.
                                - Bước 4. Trở lại bước 3.
                                - Bước 5. Phần tử lớn nhất dãy a chính là amax. ết thúc. Nhận x t :
                                - Nếu mảng chỉ có 1 phần tử thì phần tử đó là ố lớn nhất.
                                - Giả ử mảng có N phần tử và ta đã xác định được phần tử lớn nhất là amax . Nếu b ung
                                thêm phần tử thứ an+1 vào dãy mà an+1 > amax thì an+1 chính là phần tử lớn nhất của mảng
                                có N+1 phần tử. Trường hợp ngược lại, nghĩa là an+1 < amax thì amax vẫn là phần tử lớn
                                    nhất của mảng có N+1 phần tử. Trong thuật toán trên, để đơn giản, ta chỉ xem chi phí
                                    là số lần so sánh ở bước 3.1 và số lần ghi nhớ trong bước 3.1, như thế : - Trường
                                    hợp tốt nhất của thuật toán này xảy ra khi con số lớn nhất nằm đầu dãy (amax=a1) -
                                    Trường hợp xấu nhất xảy ra khi con số lớn nhất nằm ở cuối dãy (amax=aN) và dãy được
                                    sắp xếp theo thứ tự t ng dần. Dựa theo ơ đồ khối của thuật toán, ta nhận thấy rằng,
                                    trong mọi trường hợp của bài toán, thao tác ở bước 3.1 luôn được thực hiện và số lần
                                    thực hiện là N - 1 (ứng với việc xét từ phần tử a2 đến aN). Ta gọi đ y là chi phí cố
                                    định hoặc bất biến của thuật toán. Trường hợ ố nhấ : Do amax=a1 , suy ra với mọi i>
                                    2, ai< amax. Do đó, điều kiện ai> amax ở bước 3.1 luôn không thỏa mãn nên thao tác
                                        ghi nhớ không bao

                                        giờ được thực hiện. Như vậy, chi phí chung cho trường hợp này chính là chi phí
                                        cố định của bài toán.
                                        T = f(N) = N-1
                                        Trường hợ xấ nhấ :
                                        Ta có với mọi i>1, ai-1< ai do định nghĩa mảng được ắp xếp t ng dần) nên điều
                                            kiện ai>amax ở bước 3.1 luôn thỏa mãn, thao tác ghi nhớ luôn được thực hiện.
                                            Như vậy, ngoài chi phí chung là N-1 phép so
                                            ánh, ta cần phải d ng thêm N-1 thao tác ghi nhớ ở bước 3.1. Như vậy, t ng
                                            chi phí của trường hợp này
                                            T = f(N) = 2(N-1) = 2N-2
                                            Tuy chi phí của thuật toán trong trường hợp tốt nhất và xấu nhất có thể nói
                                            lên nhiều điều, nhưng vẫn chưa đưa ra được một hình dung tốt nhất về độ phức
                                            tạp của thuật toán. Ðể có thể hình dung chính xác về độ phức tạp của thuật
                                            toán, ta x t đến một yếu tố khác là độ t ng của chi phí khi độ lớn N của dữ
                                            liệu đầu vào t ng.
                                            Th o định nghĩa ở trên, ta nhận thấy chi phí thấp nhất và lớn nhất của thuật
                                            toán tìm ố lớn nhất đều bị chặn bởi O N) tồn tại hằng ố C = 10, k = 1 để 2N
                                            - 2 < 10N với mọi N>1).
                                                Một cách t ng quát, nếu hàm chi phí của thuật toán x t trong một trường
                                                hợp nào đó) bị chặn bởi O f N)) thì ta nói rằng thuật toán có độ phức
                                                tạp là O f N)) trong trường hợp đó.
                                                Như vậy, thuật toán tìm ố lớn nhất có độ phức tạp trong trường hợp tốt
                                                nhất và xấu nhất đều là O N). Người ta gọi các thuật toán có độ phức tạp
                                                O N) là các thuật toán có độ phức tạp tuyến tính.
                                                Bảng dưới đ y thể hiện độ phức tạp của thuật toán được sử dụng rộng rãi.
                                                ác độ phức tạp được sắp xếp theo thứ tự t ng dần.

                                                Tên Ký hiệu
                                                Độ phức tạp hằng số O(C)
                                                Độ phức tạp logarith O(log(N))
                                                Độ phức tạp tuyến tính O(N)
                                                Độ phức tạp NlogN O(N*log(N))

                                                Độ phức tạp đa thức O(Nk)
                                                Độ phức tạp lũy thừa O(aN)
                                                Độ phức tạp giai thừa O(N!)

                                                1.2.5. Các chiến th ết kế thuật toán
                                                Có thể thấy rằng, không có một phương pháp nào có thể giúp ta thiết kế
                                                nên các thuật toán cho tất cả các loại bài toán. Tuy nhiên, các nhà khoa
                                                học máy tính đã nghiên cứu và đưa ra các chiến lược thiết kế các giải
                                                thuật chung nhất áp dụng cho các loại bài toán khác nhau như là các
                                                phương pháp tiếp cận chung trong thiết kế thuật toán.

                                                1.2.5.1. Duyệt toàn bộ
                                                Chiến lược duyệt toàn bộ là chiến lược mà m i người lập trình nên nghĩ
                                                đến đầu tiên khi giải quyết bất cứ bài toán nào. Trong phương pháp này,
                                                ta ẽ x m x t tất cả các ứng cử viên thuộc một không gian có thể có của
                                                bài toán để x m đó có phải là nghiệm của bài toán hay không. Phương pháp
                                                này yêu cầu có một hàm kiểm tra xem một ứng cử viên nào đó có phải là
                                                nghiệm của bài toán hay không. Phương pháp này dễ hiểu, ong không dễ
                                                thực hiện và đặc biệt là không hiệu quả đối với các bài toán mà kích
                                                thước dữ liệu đầu vào lớn.

                                                1.2.5.2. Đệ qui quay lui
                                                Chiến lược đệ qui quay lui là chiến lược xây dựng thuật toán dựa trên
                                                quan hệ đệ qui. Nghiệm của bài toán được mô hình hóa dưới dạng một
                                                véc-tơ, m i thành phần của véc-tơ nghiệm sẽ có một tập giá trị có thể
                                                nhận và thuật toán sẽ tiến hành các bước gán các giá trị có thể cho các
                                                thành phần của nghiệm để xác định đúng nghiệm của bài toán. Mặc d ,
                                                không phải bài toán nào cũng có thể áp dụng, song các thuật toán dựa
                                                trên phương pháp đệ qui quay lui luôn có ự ngắn gọn, súc tích.

                                                1.2.5.3. hia để trị
                                                hiến lươc chia để tri là chiến lược quan trọng trong thiết kế các thuật
                                                toán. tưởng của chiến lươc này rất đơn giản, khi cần giải quyết mô bài
                                                toán, ta ẽ tiến hành chia bài toán đó thành các bài toán nhỏ hơn. Tiến
                                                hành thực hiện giải các bài toán nhỏ hơn đó và au đó kết hợp nghiệm của
                                                các bài toán nhỏ hơn đã giải lại thành nghiệm của bài toán ban đầu.

                                                1.2.5.4. hiến lược tham lam
                                                Chiến lược tham lam là chiến lược xây dựng thuật toán tìm nghiệm tối ưu
                                                cục bộ cho các bài toán tối ưu nhằm đạt được nghiệm tối ưu toàn cục cho
                                                cả bài toán. Trong trường hợp cho nghiệm đúng, lời giải của chiến lược
                                                tham lam thường rất dễ cài đặt và có hiệu n ng cao.
                                                1.2.5.5. Qui hoạch động
                                                Qui hoạch động là chiến lược xây dựng thuật toán để giải quyết các bài
                                                toán tối ưu. Trong chiến lược này, ta sẽ xây dựng các quan hệ đệ qui của
                                                bài toán, bài toán gốc sẽ có lời giải dựa trên các bài toán con dựa trên
                                                quan hệ đệ qui. Các thuật toán qui hoạch động thường ử dụng các cấu trúc
                                                bảng để lưu lại giá trị nghiệm của các bài toán con qua từng bước và có
                                                hai cách tiếp cận: đi từ dưới lên trên (bottom up) và đi từ trên xuống
                                                dưới (top down) để giải quyết bài toán ban đầu.

                                                1.3. KIỂU DỮ LIỆ C C Ữ LIỆU

                                                1.3.1. Ki u dữ liệu
                                                1.3.1.1. Định nghĩa
                                                Theo Peter Brass trong Advanced Data Structures, Cambridge University
                                                Press, 2008 [1], kiểu dữ liệu là một tập hợp các giá trị và một tập hợp
                                                các phép toán trên các giá trị đó.

                                                1.3.1.2. Các kiểu dữ liệu
                                                Có hai kiểu dữ liệu là kiểu dữ liệu cơ bản và kiểu dữ liệu có cấu trúc.
                                                Kiểu dữ liệu cơ bản thường là các loại dữ liệu đơn giản và không có cấu
                                                trúc, bao gồm: các giá trị kiểu số như ố nguyên, số thực, các giá trị
                                                logic,… ác ngôn ngữ lập trình thường cung cấp sẵn kiểu dữ liệu này cho
                                                người lập trình và thường được gọi là các kiểu dữ liệu cơ sở. Tùy theo
                                                các ngôn ngữ lập trình khác nhau mà các kiểu dữ liệu cơ sở có thể khác
                                                nhau về cách thức khai báo, sử dụng, miền giá trị, cũng như các ph p
                                                toán trên đó.
                                                Ví dụ :
                                                Kiểu số nguyên, không dấu trong ngôn ngữ được khai báo sử dụng bằng từ
                                                khóa un ign int, có kích thước 2 bytes và có miền giá trị từ giá trị 0
                                                đến 65535.
                                                Trong thực tế, khi giải quyết các bài toán, bản thân các kiểu dữ liệu cơ
                                                ở không đủ để biểu diễn các dữ liệu đa dạng, do đó nhu cầu xây dựng các
                                                kiểu dữ liệu mới là cần thiết. Các kiểu dữ liệu mới thường được xây dựng
                                                dựa trên các kiểu dữ liệu cơ ở của ngôn ngữ lập trình. Những kiểu dữ
                                                liệu mới này được gọi là các kiểu dữ liệu cấu trúc.
                                                Ví dụ:
                                                Kiểu dữ liệu nhân viên, bao gồm các thông tin: mã nhân viên, tên nhân
                                                viên, ngày inh, địa chỉ thường trú, ngày tuyển dụng, chức vụ được tạo ra
                                                từ các kiểu dữ liệu cơ ở, như au
                                                 Mã nhân viên: kiểu số
                                                 Tên nhân viên: kiểu chu i ký tự
                                                 Ngày sinh: kiểu ngày tháng n m
                                                 Địa chỉ thường trú: kiểu chu i ký tự
                                                 Ngày tuyển dụng: kiểu ngày tháng n m

                                                 Chức vụ: kiểu chu i ký tự
                                                Các kiểu dữ liệu cấu trúc ph biến thường sử dụng:
                                                 Kiểu dữ liệu danh sách liên kết
                                                 Kiểu dữ liệu bản ghi
                                                 Kiểu dữ liệu cây
                                                 Kiểu dữ liệu bảng b m
                                                1.3.2. u t ữ liệu
                                                Theo và Donald Knuth trong The Art of Computer Programming, 1997 [2],
                                                cấu trúc dữ liệu là cách lưu dữ liệu trong máy tính sao cho dữ liệu có
                                                thể được sử dụng một cách hiệu quả.
                                                Tính hiệu quả được thể hiện qua các đặc điểm: chính xác, tối ưu về bộ
                                                nhớ, khả n ng h trợ các thao tác tìm kiếm, truy xuất, khả n ng cập nhật,
                                                thêm hoặc xóa trên dữ liệu và cuối c ng là tính đơn giản và dễ hiểu.
                                                Trong thiết kế và xây dựng một chương trình máy tính, việc chọn cấu trúc
                                                dữ liệu là vấn đề quan trọng, đặc biệt với các chương trình lớn lại càng
                                                có tầm quan trọng cao, vì tính hiệu quả phụ thuộc rất nhiều vào cách
                                                thức t chức và lưu trữ dữ liệu.
                                                M i loại cấu trúc dữ liệu phù hợp với một vài loại ứng dụng khác nhau,
                                                ví dụ cách t chức dữ liệu theo cấu trúc cây đặc biệt phù hợp với các yêu
                                                cầu cần phân nhóm dữ liệu. Thông thường, sau khi cấu trúc dữ liệu được
                                                chọn phù hợp, ta sẽ x m x t đến thuật toán cần sử dụng. Nhưng đôi khi
                                                trình tự công việc diễn ra theo thứ tự ngược lại, khi đó cấu trúc dữ
                                                liệu được chọn phụ thuộc vào những bài toán đã có trước thuật toán và
                                                cần cải tiến để chạy tốt nhất với cách t chức dữ liệu khác. Rõ ràng,
                                                trong cả hai trường hợp, việc lựa chọn cấu trúc dữ liệu là rất quan
                                                trọng.
                                                Thông thường, một cấu trúc dữ liệu được chọn c n thận ẽ cho ph p thực
                                                hiện thuật toán hiệu quả hơn. Việc chọn cấu trúc dữ liệu thường bắt đầu
                                                từ chọn một cấu trúc dữ liệu trừu tượng. Một cấu trúc

                                                dữ liệu được thiết kế tốt cho ph p thực hiện nhiều ph p toán, ử dụng
                                                càng ít tài nguyên, thời gian xử lý và không gian bộ nhớ càng tốt.
                                                ác cấu trúc dữ liệu được x y dựng bằng cách ử dụng các kiểu dữ liệu cơ
                                                bản và các ph p toán trên đó được cung cấp bởi một ngôn ngữ lập trình cụ
                                                thể.Tri thức đó đã dẫn đến ự phát triển của nhiều ngôn ngữ lập trình và
                                                phương pháp thiết kế được hình thức hóa, mà trong đó, nh n tố t chức
                                                quan trọng là các cấu trúc dữ liệu chứ không phải các thuật toán. Đa ố
                                                ngôn ngữ lập trình có một tính n ng thuộc dạng hệ thống modul hóa cho ph
                                                p các cấu trúc dữ liệu được tái ử dụng an toàn trong các ứng dụng khác
                                                nhau.




                                                1.5 BÀI TẬP CHƯƠNG 1
                                                1. Vì sao các ngôn ngữ lập trình thường cung cấp trước một số kiểu dữ
                                                liệu cơ bản? Giải thích mục đích của việc này?
                                                2. ó nên định nghĩa thêm các kiểu dữ liệu mới từ các kiểu dữ liệu cơ
                                                bản? Khi nào ta cần làm việc này?
                                                3. Cho 3 ví dụ minh họa về mối quan hệ giữa cấu trúc dữ liệu và thuật
                                                toán.
                                                4. Cho ví dụ minh họa để giải thích cho câu phát biểu sau:“Một cấu trúc
                                                dữ liệu tồi, không thể cứ vãn được một thuật toán tố ”
                                                5. Khi tiếp cận để giải quyết một vấn đề hoặc bài toán, bạn thường quan
                                                t m đến xây dựng cách thức t chức, quản lý dữ liệu trước hay cách thức
                                                giải quyết vấn đề hoặc bài toán trước? Vì sao? Cho ví dụ minh họa để
                                                giải thích.
                    </p>
                </div>
                <div class="tab-pane" id="chapter2">
                    <h2>CHƯƠNG 2. SẮP XẾP VÀ TÌM KIẾM</h2>
                    <button class="btn" onclick="document.getElementById('file-input').click()">Chọn tệp PDF</button>
                    <div id="pdf-container">
                        <input type="file" id="file-input" accept=".pdf" style="display: none;">

                        <div id="pdf-pages"></div>
                    </div>
                </div>

                <div class="tab-pane" id="chapter3">
                    <h2>CHƯƠNG 3. DANH SÁCH LIÊN KẾT</h2>

                </div>
                <div class="tab-pane" id="chapter4">
                    <h2>CHƯƠNG 4. NGĂN XẾP HÀNG ĐỢI</h2>

                </div>
                <div class="tab-pane" id="chapter5">
                    <h2>CHƯƠNG 5. CÂY</h2>

                </div>
                <div class="tab-pane" id="chapter6">
                    <h2>CHƯƠNG 6. BẢNG BĂM</h2>

                </div>
                <div class="tab-pane" id="chapter7">
                    <h2>CHƯƠNG 7. TÀI LIỆU THAM KHẢO</h2>

                </div>
            </div>
        </div>
    </div>
    <footer class="footer">
    </footer>
    <!-- Javascript -->
    <script src="./js/content.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>


</body>

</html>